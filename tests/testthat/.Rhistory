breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"breakTiesStochastic and breakTiesByColumns are mutually exclusive. When both set, breakTiesStochastic will take precedence.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL),
"When breakTiesStochastic is FALSE and breakTiesByColumns is NULL, ties are broken by taking the sequence that appears earlier in the data.frame.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=TRUE, breakTiesStochastic=TRUE),
"includeAmbiguous and breakTiesStochastic are mutually exclusive. When both TRUE, includeAmbiguous will take precedence.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=FALSE, breakTiesStochastic=FALSE),
"When both includeAmbiguous and breakTiesStochastic are FALSE, ties are broken in the order of 'A', 'T', 'G', 'C', 'N', '.', and '-'.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=TRUE, breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"breakTiesByColumns is ignored when method is thresholdedFreq or mostCommon.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=TRUE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"breakTiesStochastic and breakTiesByColumns are mutually exclusive. When both set, breakTiesStochastic will take precedence.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL),
"When breakTiesStochastic is FALSE and breakTiesByColumns is NULL, ties are broken by taking the sequence that appears earlier in the data.frame.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max)),
includeAmbiguous=TRUE),
"includeAmbiguous is ignored when method is mostMutated or leastMutated.")
?collapseClones
test.mut = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=TRUE)
colnames(test.mut)
expect_equal(test.mut[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$obsv[5], 3))
test.mut[["CLONAL_SEQUENCE_MUFREQ"]]
expect_equal(test.mut[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[5], 3))
test.mut = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[5], 3))
test.mut
test.mut.least = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="leastMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.most[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[1], 3)) # from test 2D
test.mut.least = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="leastMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.least[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[1], 3)) # from test 2D
test.mut.most = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.most[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[5], 3)) # from test 2D
rm(test.mut)
test.mut.most = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.most[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[5], 3)) # from test 2D
test.mut.least = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="leastMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.least[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[1], 3)) # from test 2D
test.mut.least
test.expF = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn="MUTFREQ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
test.expT = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn="MUTFREQ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=TRUE)
expect_true(nrow(test.expT)==(3*nrow(test.expF)))
nrow(test.expT)
expect_equal(nrow(test.expF), 3) # 3 clones
expect_equal(nrow(test.expT), nrow(testDb.clone))
test.expF
test.expT
expect_equal(length(unique(test.expF[["CLONE"]])), 3) # 3 clones
expect_equal(nrow(test.expT), nrow(testDb.clone))
expect_equal(table(test.expT[["CLONE"]]), rep(nrow(testDb), 3))
table(test.expT[["CLONE"]])
rep(nrow(testDb), 3)
expect_equivalent(table(test.expT[["CLONE"]]), rep(nrow(testDb), 3))
expect_equivalent(as.vector(table(test.expT[["CLONE"]])), rep(nrow(testDb), 3))
as.vector(table(test.expT[["CLONE"]]))
expect_equal(as.vector(table(test.expT[["CLONE"]])), rep(nrow(testDb), 3))
test.expF
expect_equal(length(unique(test.expT[["MUTFREQ"]])), nrow(testDb))
expect_equal(length(unique(test.expT[["CLONAL_SEQUENCE_MUFREQ"]])), nrow(testDb))
length(unique(test.expT[["MUTFREQ"]]))
expect_equal(length(unique(test.expT[["MUTFREQ"]])), length(unique(testDb$MUTFREQ)))
expect_equal(length(unique(test.expT[["CLONAL_SEQUENCE_MUFREQ"]])), 1)
expect_equal(length(unique(test.expT[["MUTFREQ"]])), length(unique(testDb$MUTFREQ)))
test_that("calcClonalConsensusHelper, 2C, methods = mostMutated, leastMutated", {
# seq1: DUPCOUNT=37; CONSCONT=25; ERR=0.3
# obsv: [full length=15] 1 R; nonN=15; muFreq = 1/15
# obsv: ATG CAT GCA TGC ATA
# germ: ATG CAT GCA TGC ATG
# seq2: DUPCOUNT=9; CONSCONT=8; ERR=0.076
# obsv: [full length=18] 1 R; 1 S; nonN=18; muFreq = 2/18
# obsv: ATG CAT GCG TGC ATA CGT
# germ: ATG CAT GCA TGC ATG CGT
# seq3: DUPCOUNT=37; CONSCONT=25; ERR=0.23
# obsv: [full length=17] 1 S; nonN=15; muFreq = 1/15
# obsv: ATG CAC GCG TGC ATG CC
# germ: ATG CAC GCA TGC ATG CC
# germ: 2nd codon CAC instead of CAT
# seq4: DUPCOUNT=34; CONSCONT=25; ERR=0.44
# obsv: [full length=15] 1 S; nonN=15; muFreq = 1/15
# obsv: ATG CAC GCG TGC ATG
# germ: ATG CAC GCA TGC ATG
# germ: 2nd codon CAC instead of CAT
# seq5: DUPCOUNT=11; CONSCONT=20; ERR=0.14
# obsv: [full length=19] 1 R; 2 S; nonN=18 (ignoring non-triplet overhang); muFreq = 3/18
# obsv: ATG CAT GCG TGT ATA CGC G
# germ: ATG CAT GCA TGC ATG CGT G
# seq6: DUPCOUNT=11; CONSCONT=20; ERR=0.12
# obsv: [full length=20] 2 R; 1 S; nonN=18; muFreq = 3/18
# obsv: ATG CAT GCA TGT ATA CGT GA
# germ: ATT CAT GCA TGC ATG CGT GA
# germ: 1st codon ATT instead of ATG
# seq7: DUPCOUNT=11; CONSCONT=16; ERR=0.17
# obsv: [full length=18] 2 R; 1 S; nonN=18; muFreq = 3/18
# obsv: ATG CAT GCA TGT ATA CGT
# germ: ATT CAT GCA TGC ATG CGT
# germ: 1st codon ATT instead of ATG
testDb = data.frame(obsv=c("ATGCATGCATGCATA",      # seq1
"ATGCATGCGTGCATACGT",   # seq2
"ATGCACGCGTGCATGCC",      # seq3
"ATGCACGCGTGCATG",      # seq4
"ATGCATGCGTGTATACGTG",  # seq5
"ATGCATGCATGTATACGTGA", # seq6
"ATGCATGCATGTATACGT"    # seq7
),
germ=c("ATGCATGCATGCATG",      # seq1
"ATGCATGCATGCATGCGT",   # seq2
"ATGCACGCATGCATGCC",      # seq3
"ATGCACGCATGCATG",      # seq4
"ATGCATGCATGCATGCGTG",  # seq5
"ATTCATGCATGCATGCGTGA", # seq6
"ATTCATGCATGCATGCGT"    # seq7
),
DUPCOUNT=c(37,9,37,34,11,11,11),
CONSCOUNT=c(25,8,25,25,20,20,16),
ERR=c(0.3, 0.076, 0.23, 0.44, 0.14, 0.12, 0.17),
MUTFREQ=c(1/15,2/18,1/15,1/15,3/18,3/18,3/18),
stringsAsFactors=FALSE)
#observedMutations(testDb, "obsv", "germ", frequency=F, combine=F)
#observedMutations(testDb, "obsv", "germ", frequency=T, combine=T)
#calcObservedMutations(inputSeq = testDb$obsv[4], germlineSeq = testDb$germ[4], frequency=F, returnRaw=T)
# check mutation frequency
expect_true(all(observedMutations(testDb, "obsv", "germ", frequency=T, combine=T)$MU_FREQ ==
testDb$MUTFREQ))
##### mostMutated
### resolve ties stochastically
most.sto.possible = testDb$obsv[5:7]
most.sto.1 = replicate(100,
shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=TRUE,
breakTiesByColumns=NULL,
lenLimit=NULL)$cons)
# when both breakTiesStochastic and breakTiesByColumns TRUE, breakTiesStochastic takes precedence
most.sto.2 = replicate(100,
shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=TRUE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT", "ERR"),
c(max,max,min)),
lenLimit=NULL)$cons)
expect_true(all(most.sto.1 %in% most.sto.possible))
expect_true(all(most.sto.2 %in% most.sto.possible))
# check length
expect_true(all( nchar(most.sto.1) %in% nchar(most.sto.possible) ))
expect_true(all( nchar(most.sto.2) %in% nchar(most.sto.possible) ))
### resolve ties by columns
# 3 columns; able to resolve
# DUPCOUNT gives 5&6&7; CONSCOUNT gives 5&6; ERR gives 6
most.byCol.1 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT", "ERR"),
c(max,max,min)),
lenLimit=NULL)$cons
expect_equal(most.byCol.1, testDb$obsv[6])
# 1 column; able to resolve
# ERR gives 6
most.byCol.2 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("ERR"),
c(min)),
lenLimit=NULL)$cons
expect_equal(most.byCol.2, testDb$obsv[6])
# 2 columns; unable to resolve; returns sequence that appears first
# DUPCOUNT gives 5&6&7; CONSCOUNT gives 5&6; 5 appears before 6, returns 5
most.byCol.3 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"),
c(max,max)),
lenLimit=NULL)$cons
expect_equal(most.byCol.3, testDb$obsv[5])
### resolve ties deterministically by returning sequence that appears first (index 5)
most.det.1 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=NULL,
lenLimit=NULL)$cons
expect_equal(most.det.1, testDb$obsv[5])
### check length when lenLimit is supplied
most.det.2 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="mostMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=NULL,
lenLimit=7)$cons
expect_equal(most.det.2, substr(testDb$obsv[5], 1, 7))
##### leastMutated
### resolve ties stochastically
least.sto.possible = testDb$obsv[c(1,3,4)]
least.sto.1 = replicate(100,
shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=TRUE,
breakTiesByColumns=NULL,
lenLimit=NULL)$cons)
# when both breakTiesStochastic and breakTiesByColumns TRUE, breakTiesStochastic takes precedence
least.sto.2 = replicate(100,
shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=TRUE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT", "ERR"),
c(max,max,min)),
lenLimit=NULL)$cons)
expect_true(all(least.sto.1 %in% least.sto.possible))
expect_true(all(least.sto.2 %in% least.sto.possible))
# check length
expect_true(all( nchar(least.sto.1) %in% nchar(least.sto.possible) ))
expect_true(all( nchar(least.sto.2) %in% nchar(least.sto.possible) ))
### resolve ties by columns
# 3 columns; able to resolve
# DUPCOUNT gives 1&3; CONSCOUNT gives 1&3; ERR gives 3
least.byCol.1 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT", "ERR"),
c(max,max,min)),
lenLimit=NULL)$cons
expect_equal(least.byCol.1, testDb$obsv[3])
# 1 column; able to resolve
# ERR gives 3
least.byCol.2 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("ERR"),
c(min)),
lenLimit=NULL)$cons
expect_equal(least.byCol.2, testDb$obsv[3])
# 2 columns; unable to resolve; returns sequence that appears first
# DUPCOUNT gives 1&3; CONSCOUNT gives 1&3; 1 appears before 3, returns 1
least.byCol.3 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"),
c(max,max)),
lenLimit=NULL)$cons
expect_equal(least.byCol.3, testDb$obsv[1])
### resolve ties deterministically by returning sequence that appears first (index 1)
least.det.1 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=NULL,
lenLimit=NULL)$cons
expect_equal(least.det.1, testDb$obsv[1])
### check length when lenLimit is supplied
least.det.2 = shazam:::calcClonalConsensusHelper(seqs=testDb$obsv, muFreqColumn="MUTFREQ", db=testDb,
mtd="leastMutated",
breakTiesStochastic=FALSE,
breakTiesByColumns=NULL,
lenLimit=7)$cons
expect_equal(least.det.2, substr(testDb$obsv[1], 1, 7))
})
test_that("calcClonalConsensus, 2D", {
##### same testDb from test 2C for calcClonalConsensusHelper
testDb = data.frame(obsv=c("ATGCATGCATGCATA",      # seq1
"ATGCATGCGTGCATACGT",   # seq2
"ATGCACGCGTGCATGCC",      # seq3
"ATGCACGCGTGCATG",      # seq4
"ATGCATGCGTGTATACGTG",  # seq5
"ATGCATGCATGTATACGTGA", # seq6
"ATGCATGCATGTATACGT"    # seq7
),
germ=c("ATGCATGCATGCATG",      # seq1
"ATGCATGCATGCATGCGT",   # seq2
"ATGCACGCATGCATGCC",      # seq3
"ATGCACGCATGCATG",      # seq4
"ATGCATGCATGCATGCGTG",  # seq5
"ATTCATGCATGCATGCGTGA", # seq6
"ATTCATGCATGCATGCGT"    # seq7
),
DUPCOUNT=c(37,9,37,34,11,11,11),
CONSCOUNT=c(25,8,25,25,20,20,16),
ERR=c(0.3, 0.076, 0.23, 0.44, 0.14, 0.12, 0.17),
MUTFREQ=c(1/15,2/18,1/15,1/15,3/18,3/18,3/18),
stringsAsFactors=FALSE)
##### run calcClonalConsensus
# no region definition
test.result.noRegDef = shazam:::calcClonalConsensus(db=testDb,
sequenceColumn="obsv",
germlineColumn="germ",
muFreqColumn="MUTFREQ",
regionDefinition=NULL,
method="mostMutated",
minimumFrequency=NULL, includeAmbiguous=FALSE,
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("ERR"), c(min)))
# with region definition
test.regDef = createRegionDefinition(boundaries=factor(rep(c("W","Y"), each=6)))
test.result.regDef = shazam:::calcClonalConsensus(db=testDb,
sequenceColumn="obsv",
germlineColumn="germ",
muFreqColumn="MUTFREQ",
regionDefinition=test.regDef,
method="mostMutated",
minimumFrequency=NULL, includeAmbiguous=FALSE,
breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("ERR"), c(min)))
##### returned object should be a list
expect_true(is.list(test.result.noRegDef))
expect_true(is.list(test.result.regDef))
# of length 3
expect_equal(length(test.result.noRegDef), 3)
expect_equal(length(test.result.regDef), 3)
# with entries named inputCons, germlineCons, and inputMuFreq
expect_equal(names(test.result.noRegDef), c("inputCons", "germlineCons", "inputMuFreq"))
expect_equal(names(test.result.regDef), c("inputCons", "germlineCons", "inputMuFreq"))
# entries should be character, character, and numeric
expect_equal(unlist(lapply(test.result.noRegDef, class)),
c(inputCons="character", germlineCons="character", inputMuFreq="numeric"))
expect_equal(unlist(lapply(test.result.regDef, class)),
c(inputCons="character", germlineCons="character", inputMuFreq="numeric"))
##### germlineCons should be generated from mostCommon method using the same additional parameter setting
# generate mostCommon germline using calcClonalConsensusHelper (tested in test 2B)
exp.germ.noRegDef = shazam:::calcClonalConsensusHelper(seqs=testDb$germ, mtd="mostCommon",
includeAmbiguous=FALSE,
breakTiesStochastic=FALSE,
lenLimit=NULL)
exp.germ.regDef = shazam:::calcClonalConsensusHelper(seqs=testDb$germ, mtd="mostCommon",
includeAmbiguous=FALSE,
breakTiesStochastic=FALSE,
lenLimit=test.regDef@seqLength)
expect_equal(test.result.noRegDef$germlineCons, exp.germ.noRegDef$cons)
expect_equal(test.result.regDef$germlineCons, exp.germ.regDef$cons)
##### inputCons and germlineCons lengths should be the same
expect_equal(nchar(test.result.noRegDef$germlineCons), nchar(test.result.noRegDef$inputCons))
expect_equal(nchar(test.result.regDef$germlineCons), nchar(test.result.regDef$inputCons))
##### inputCons and germlineCons lengths should both be <= regDef@seqLength if supplied
expect_true(nchar(test.result.regDef$germlineCons) <= test.regDef@seqLength)
expect_true(nchar(test.result.regDef$inputCons) <= test.regDef@seqLength)
})
test_that("calcClonalConsensus, 2E", {
##### same testDb from test 2C for calcClonalConsensusHelper
testDb = data.frame(obsv=c("ATGCATGCATGCATA",      # seq1
"ATGCATGCGTGCATACGT",   # seq2
"ATGCACGCGTGCATGCC",      # seq3
"ATGCACGCGTGCATG",      # seq4
"ATGCATGCGTGTATACGTG",  # seq5
"ATGCATGCATGTATACGTGA", # seq6
"ATGCATGCATGTATACGT"    # seq7
),
germ=c("ATGCATGCATGCATG",      # seq1
"ATGCATGCATGCATGCGT",   # seq2
"ATGCACGCATGCATGCC",      # seq3
"ATGCACGCATGCATG",      # seq4
"ATGCATGCATGCATGCGTG",  # seq5
"ATTCATGCATGCATGCGTGA", # seq6
"ATTCATGCATGCATGCGT"    # seq7
),
DUPCOUNT=c(37,9,37,34,11,11,11),
CONSCOUNT=c(25,8,25,25,20,20,16),
ERR=c(0.3, 0.076, 0.23, 0.44, 0.14, 0.12, 0.17),
MUTFREQ=c(1/15,2/18,1/15,1/15,3/18,3/18,3/18),
stringsAsFactors=FALSE)
##### create 3 identical clones from testDb
testDb.clone = rbind(testDb, testDb, testDb)
testDb.clone$CLONE = rep(c("124", "39", "5"), each=nrow(testDb))
##### check input checks/warnings
# method
expect_error(collapseClones(db=testDb.clone, method="nonExistingMethod"))
# minimumFrequency for thresholdedFreq
expect_error(collapseClones(db=testDb.clone, method="thresholdedFreq", minimumFrequency=NULL),
"minimumFrequency must be a numeric value.")
expect_error(collapseClones(db=testDb.clone, method="thresholdedFreq", minimumFrequency=1.3),
"minimumFrequency must be between 0 and 1.")
expect_error(collapseClones(db=testDb.clone, method="thresholdedFreq", minimumFrequency=(-1.3)),
"minimumFrequency must be between 0 and 1.")
# includeAmbiguous & breakTiesStochastic for methods other than catchAll
expect_error(collapseClones(db=testDb.clone, method="mostCommon",
includeAmbiguous=NULL, breakTiesStochastic=FALSE),
"includeAmbiguous must be TRUE or FALSE.")
expect_error(collapseClones(db=testDb.clone, method="mostCommon",
includeAmbiguous=FALSE, breakTiesStochastic=NULL),
"breakTiesStochastic must be TRUE or FALSE.")
# breakTiesByColumns and muFreqColumn for methods most/leastMutated
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns="notList"),
"breakTiesByColumns must be a list.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns=list(1,2,3)),
"breakTiesByColumns must be a nested list of length 2.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns=list(c("col1", "col2"), c(max,max,min))),
"Nested vectors in breakTiesByColumns must have the same lengths.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns=list(c(12,22,3), c(max,max,min))),
"The first vector in breakTiesByColumns must contain column names.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns=list(c("col1", "col2"), c("max","max"))),
"The second vector in breakTiesByColumns must contain functions.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated",
breakTiesByColumns=list(c("col1", "col2"), c(max,max))),
"All column named included in breakTiesByColumns must be present in db.")
expect_error(collapseClones(db=testDb.clone, method="mostMutated", muFreqColumn="notInDb",
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"If specified, muFreqColumn must be a column present in db.")
# check mutual exclusivitiy
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=TRUE, breakTiesStochastic=TRUE),
"includeAmbiguous and breakTiesStochastic are mutually exclusive. When both TRUE, includeAmbiguous will take precedence.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=FALSE, breakTiesStochastic=FALSE),
"When both includeAmbiguous and breakTiesStochastic are FALSE, ties are broken in the order of 'A', 'T', 'G', 'C', 'N', '.', and '-'.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostCommon", includeAmbiguous=TRUE, breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"breakTiesByColumns is ignored when method is thresholdedFreq or mostCommon.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=TRUE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max))),
"breakTiesStochastic and breakTiesByColumns are mutually exclusive. When both set, breakTiesStochastic will take precedence.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL),
"When breakTiesStochastic is FALSE and breakTiesByColumns is NULL, ties are broken by taking the sequence that appears earlier in the data.frame.")
expect_message(collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=list(c("DUPCOUNT", "CONSCOUNT"), c(max,max)),
includeAmbiguous=TRUE),
"includeAmbiguous is ignored when method is mostMutated or leastMutated.")
##### check calling observedMutations when muFreqColumn is not specifiied
# resolve ties determinisically by taking seq that appears first
test.mut.most = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.most[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[5], 3)) # from test 2D
test.mut.least = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn=NULL,
method="leastMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
expect_equal(test.mut.least[["CLONAL_SEQUENCE_MUFREQ"]],
rep(testDb$MUTFREQ[1], 3)) # from test 2D
##### check expandedDb
# resolve ties determinisically by taking seq that appears first
test.expF = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn="MUTFREQ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=FALSE)
test.expT = collapseClones(db=testDb.clone, cloneColumn="CLONE", sequenceColumn="obsv", germlineColumn="germ",
muFreqColumn="MUTFREQ",
method="mostMutated", breakTiesStochastic=FALSE,
breakTiesByColumns=NULL, expandedDb=TRUE)
### dimension
# nrow of unexpanded should correspond to number of clones
expect_equal(nrow(test.expF), 3) # 3 clones
# there should be 3 unique clones in unexpanded
expect_equal(length(unique(test.expF[["CLONE"]])), 3) # 3 clones
# nrow of expanded should correspond to nrow of input db
expect_equal(nrow(test.expT), nrow(testDb.clone))
# number of seqs in each unique clone in expanded should correspond to that in input db
expect_equal(as.vector(table(test.expT[["CLONE"]])), rep(nrow(testDb), 3))
### muFreqColumn supplied
# when expanded, MUTFREQ for all sequences in input db should remain unchanged
expect_equal(length(unique(test.expT[["MUTFREQ"]])), length(unique(testDb$MUTFREQ)))
# when unexpended, sequenceColumn and corresponding MUTFREQ retained for each clone may
# not necessarily be the most mutated; so nothing to test here
### CLONAL_SEQUENCE_MUFREQ
# $CLONAL_SEQUENCE_MUFREQ is the mut freq of most mutated consensus for a given clone
# since all 3 clones here are artifically made the same, this number should be the same for all clones
expect_equal(length(unique(test.expF[["CLONAL_SEQUENCE_MUFREQ"]])), 1)
# $CLONAL_SEQUENCE_MUFREQ is the mut freq of most mutated consensus for a given clone
# this number should be the same for all seqs in the same clone
# since all 3 clones here are artifically made the same, this number should be the same for all seqs
expect_equal(length(unique(test.expT[["CLONAL_SEQUENCE_MUFREQ"]])), 1)
})
