{
    "collab_server" : "",
    "contents" : "# Mutation profiling\n\n#' @include Shazam.R\nNULL\n\n#### Clonal consensus building functions ####\n\n#' Constructs effective clonal sequences for all clones\n#'\n#' \\code{collapseClones} creates effective input and germline sequences for each clonal \n#' group and appends columns containing the consensus sequences to the input \n#' \\code{data.frame}.\n#'\n#' @param   db                  \\code{data.frame} containing sequence data. Required.\n#' @param   cloneColumn         \\code{character} name of the column containing clonal \n#'                              identifiers. Required.\n#' @param   sequenceColumn      \\code{character} name of the column containing input \n#'                              sequences. Required. The length of each input sequence should \n#'                              match that of its corresponding germline sequence.\n#' @param   germlineColumn      \\code{character} name of the column containing germline \n#'                              sequences. Required. The length of each germline sequence should \n#'                              match that of its corresponding input sequence.\n#' @param   muFreqColumn        \\code{character} name of the column containing mutation\n#'                              frequency. Optional. Applicable to the \\code{\"mostMutated\"}\n#'                              and \\code{\"leastMutated\"} methods. If not supplied, mutation\n#'                              frequency is computed by calling \\code{observedMutations}.\n#'                              Default is \\code{NULL}. See Cautions for note on usage.\n#' @param   regionDefinition    \\link{RegionDefinition} object defining the regions\n#'                              and boundaries of the Ig sequences. Optional. Default is \n#'                              \\code{NULL}.\n#' @param   method              method for calculating input consensus sequence. Required. One of \n#'                              \\code{\"thresholdedFreq\"}, \\code{\"mostCommon\"}, \\code{\"catchAll\"},\n#'                              \\code{\"mostMutated\"}, or \\code{\"leastMutated\"}. See \"Methods\" for \n#'                              details.\n#' @param   minimumFrequency    frequency threshold for calculating input consensus sequence.\n#'                              Applicable to and required for the \\code{\"thresholdedFreq\"} method.\n#'                              A canonical choice is 0.6. Default is \\code{NULL}. \n#' @param   includeAmbiguous    whether to use ambiguous characters to represent positions at\n#'                              which there are multiple characters with frequencies that are at least\n#'                              \\code{minimumFrequency} or that are maximal (i.e. ties). Applicable to \n#'                              and required for the \\code{\"thresholdedFreq\"} and \\code{\"mostCommon\"} \n#'                              methods. Default is \\code{FALSE}. See \"Choosing ambiguous characters\" \n#'                              for rules on choosing ambiguous characters.\n#' @param   breakTiesStochastic In case of ties, whether to randomly pick a sequence from sequences that\n#'                              fulfill the criteria as consensus. Applicable to and required for all methods\n#'                              except for \\code{\"catchAll\"}. Default is \\code{FALSE}. See \"Methods\" for \n#'                              details. \n#' @param   breakTiesByColumns  A list of the form \\code{list(c(col_1, col_2, ...), c(fun_1, fun_2, ...))}, \n#'                              where \\code{col_i} is a \\code{character} name of a column in \\code{db},\n#'                              and \\code{fun_i} is a function to be applied on that column. Currently, \n#'                              only \\code{max} and \\code{min} are supported. Note that the two \\code{c()}'s\n#'                              in \\code{list()} are essential (i.e. if there is only 1 column, the list \n#'                              should be of the form \\code{list(c(col_1), c(func_1))}. Applicable to and \n#'                              optional for the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods. \n#'                              If supplied, \\code{fun_i}'s are applied on \\code{col_i}'s to help break \n#'                              ties. Default is \\code{NULL}. See \"Methods\" for details. \n#' @param   expandedDb          \\code{logical} indicating whether or not to return the \n#'                              expanded \\code{db}, containing all the sequences (as opposed\n#'                              to returning just one sequence per clone).\n#' @param   nproc               Number of cores to distribute the operation over. If the \n#'                              \\code{cluster} has already been set earlier, then pass the \n#'                              \\code{cluster}. This will ensure that it is not reset.\n#'                              \n#' \n#' @return   A modified \\code{db} with the following additional columns: \n#'           \\itemize{\n#'             \\item \\code{CLONAL_SEQUENCE}:  effective sequence for the clone.\n#'             \\item \\code{CLONAL_GERMLINE}:  germline sequence for the clone.\n#'             \\item \\code{CLONAL_SEQUENCE_MUFREQ}:  mutation frequency of \n#'                   \\code{CLONAL_SEQUENCE}; only added for the \\code{\"mostMutated\"}\n#'                   and \\code{\"leastMutated\"} methods.\n#'           }\n#'                      \n#'           \\code{CLONAL_SEQUENCE} is generated with the method of choice indicated \n#'           by \\code{method}, and \\code{CLONAL_GERMLINE} is generated with the \n#'           \\code{\"mostCommon\"} method, along with, where applicable, user-defined \n#'           parameters such as \\code{minimumFrequency}, \\code{includeAmbiguous}, \n#'           \\code{breakTiesStochastic}, and \\code{breakTiesByColumns}.\n#'           \n#'\n#' @section Lengths of consensuses: For each clone, \\code{CLONAL_SEQUENCE} and \n#'          \\code{CLONAL_GERMLINE} have the same length. \n#'          \n#'          \\itemize{\n#'                \\item For the \\code{\"thresholdedFreq\"}, \\code{\"mostCommon\"}, and \\code{\"catchAll\"}\n#'                methods:\n#'          \n#'                The length of the consensus sequences is determined by the longest possible\n#'                consensus sequence (baesd on \\code{inputSeq} and \\code{germlineSeq}) and \n#'                \\code{regionDefinition@seqLength} (if supplied), whichever is shorter.\n#'\n#'                Given a set of sequences of potentially varying lengths, the longest possible \n#'                length of their consensus sequence is taken to be the longest length along \n#'                which there is information contained at every nucleotide position across \n#'                majority of the sequences. Majority is defined to be greater than \n#'                \\code{floor(n/2)}, where \\code{n} is the number of sequences. If the longest \n#'                possible consensus length is 0, there will be a warning and an empty string \n#'                (\\code{\"\"}) will be returned. \n#'          \n#'                If a length limit is defined by supplying a \\code{regionDefinition} via \n#'                \\code{regionDefinition@seqLength}, the consensus length will be further \n#'                restricted to the shorter of the longest possible length and \n#'                \\code{regionDefinition@seqLength}.\n#'          \n#'                \\item For the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods:\n#'                \n#'                The length of the consensus sequences depends on that of the most/least \n#'                mutated input sequence, and, if supplied, the length limit defined by \n#'                \\code{regionDefinition@seqLength}, whichever is shorter. If the germline \n#'                consensus computed using the \\code{\"mostCommon\"} method is longer than \n#'                the most/least mutated input sequence, the germline consensus is trimmed \n#'                to be of the same length as the input consensus.\n#'               \n#'           }\n#'\n#' @section Methods: The descriptions below use \"sequences\" as a generalization of input sequences\n#'          and germline sequences. \n#'          \n#'          \\itemize{\n#'          \n#'              \\item \\code{method=\"thresholdedFreq\"}\n#'              \n#'                    A threshold must be supplied to the argument \\code{minimumFrequency}. At \n#'                    each position along the length of the consensus sequence, the frequency \n#'                    of each nucleotide/character across sequences is tabulated. The \n#'                    nucleotide/character whose frequency is at least (i.e. \\code{>=}) \n#'                    \\code{minimumFrequency} becomes the consensus; if there is none, the\n#'                    consensus nucleotide will be \\code{\"N\"}.\n#'                    \n#'                    When there are ties (frequencies of multiple nucleotides/characters \n#'                    are at least \\code{minimumFrequency}), this method can be deterministic \n#'                    or stochastic, depending on additional parameters.\n#'                    \n#'                    \\itemize{\n#'                         \\item With \\code{includeAmbiguous=TRUE}, ties are resolved \n#'                               deterministically by representing ties using ambiguous characters. \n#'                               See \"Choosing ambiguous characters\" for how ambiguous characters \n#'                               are chosen.\n#'                         \\item With \\code{breakTiesStochastic=TRUE}, ties are resolved \n#'                               stochastically by randomly picking a character amongst the ties.\n#'                         \\item When both \\code{TRUE}, \\code{includeAmbiguous} takes precedence \n#'                               over \\code{breakTiesStochastic}.\n#'                         \\item When both \\code{FALSE}, the first character from the ties is \n#'                               taken to be the consensus following the order of \\code{\"A\"}, \n#'                               \\code{\"T\"}, \\code{\"G\"}, \\code{\"C\"}, \\code{\"N\"}, \\code{\".\"}, and \n#'                               \\code{\"-\"}.\n#'                    }\n#'                    \n#'                    Below are some examples looking at a single position based on 5 sequences \n#'                    with \\code{minimumFrequency=0.6}, \\code{includeAmbiguous=FALSE}, and \n#'                    \\code{breakTiesStochastic=FALSE}:\n#'                    \n#'                    \\itemize{\n#'                         \\item If the sequences have \\code{\"A\"}, \\code{\"A\"}, \\code{\"A\"}, \n#'                               \\code{\"T\"}, \\code{\"C\"}, the consensus will be \\code{\"A\"}, because \n#'                               \\code{\"A\"} has frequency 0.6, which is at least \n#'                               \\code{minimumFrequency}.\n#'                         \\item If the sequences have \\code{\"A\"}, \\code{\"A\"}, \\code{\"T\"}, \n#'                               \\code{\"T\"}, \\code{\"C\"}, the consensus will be \\code{\"N\"}, because \n#'                               none of \\code{\"A\"}, \\code{\"T\"}, or \\code{\"C\"} has frequency that \n#'                               is at least \\code{minimumFrequency}.\n#'                    }\n#'          \n#'               \\item \\code{method=\"mostCommon\"}\n#'               \n#'                     The most frequent nucleotide/character across sequences at each position \n#'                     along the length of the consensus sequence makes up the consensus.\n#'                    \n#'                     When there are ties (multiple nucleotides/characters with equally maximal \n#'                     frequencies), this method can be deterministic or stochastic, depending on \n#'                     additional parameters. The same rules for breaking ties for \n#'                     \\code{method=\"thresholdedFreq\"} apply.\n#'                    \n#'                     Below are some examples looking at a single position based on 5 sequences\n#'                     with \\code{includeAmbiguous=FALSE}, and \\code{breakTiesStochastic=FALSE}:\n#'                     \n#'                     \\itemize{\n#'                          \\item If the sequences have \\code{\"A\"}, \\code{\"A\"}, \\code{\"T\"}, \n#'                                \\code{\"A\"}, \\code{\"C\"}, the consensus will be \\code{\"A\"}.\n#'                          \\item If the sequences have \\code{\"T\"}, \\code{\"T\"}, \\code{\"C\"}, \n#'                                \\code{\"C\"}, \\code{\"G\"}, the consensus will be \\code{\"T\"}, \n#'                                because \\code{\"T\"} is before \\code{\"C\"} in the order of \n#'                                \\code{\"A\"}, \\code{\"T\"}, \\code{\"G\"}, \\code{\"C\"}, \\code{\"N\"}, \n#'                                \\code{\".\"}, and \\code{\"-\"}. \n#'                     }       \n#'                     \n#'                     \n#'               \\item \\code{method=\"catchAll\"}\n#'               \n#'                     This method returns a consensus sequence capturing most of the information \n#'                     contained in the sequences. Ambiguous characters are used where applicable.\n#'                     See \"Choosing ambiguous characters\" for how ambiguous characters are chosen.\n#'                     This method is deterministic and does not involve breaking ties.\n#'                     \n#'                     Below are some examples for \\code{method=\"catchAll\"} looking at a single \n#'                     position based on 5 sequences:\n#'                     \n#'                     \\itemize{\n#'                          \\item If the sequences have \\code{\"N\"}, \\code{\"N\"}, \\code{\"N\"}, \n#'                                \\code{\"N\"}, \\code{\"N\"}, the consensus will be \\code{\"N\"}.\n#'                          \\item If the sequences have \\code{\"N\"}, \\code{\"A\"}, \\code{\"A\"}, \n#'                                \\code{\"A\"}, \\code{\"A\"}, the consensus will be \\code{\"A\"}.\n#'                          \\item If the sequences have \\code{\"N\"}, \\code{\"A\"}, \\code{\"G\"}, \n#'                                \\code{\"A\"}, \\code{\"A\"}, the consensus will be \\code{\"R\"}.\n#'                          \\item If the sequences have \\code{\"-\"}, \\code{\"-\"}, \\code{\".\"}, \n#'                                \\code{\".\"}, \\code{\".\"}, the consensus will be \\code{\"-\"}.\n#'                          \\item If the sequences have \\code{\"-\"}, \\code{\"-\"}, \\code{\"-\"}, \n#'                                \\code{\"-\"}, \\code{\"-\"}, the consensus will be \\code{\"-\"}.\n#'                          \\item If the sequences have \\code{\".\"}, \\code{\".\"}, \\code{\".\"}, \n#'                                \\code{\".\"}, \\code{\".\"}, the consensus will be \\code{\".\"}.\n#'                    }\n#'                    \n#'              \\item \\code{method=\"mostMutated\"} and \\code{method=\"leastMutated\"}\n#'              \n#'                    These methods return the most/least mutated sequence as the consensus \n#'                    sequence. \n#'                    \n#'                    When there are ties (multple sequences have the maximal/minimal mutation\n#'                    frequency), this method can be deterministic or stochastic, depending on \n#'                    additional parameters.\n#'                    \n#'                    \\itemize{\n#'                         \\item With \\code{breakTiesStochastic=TRUE}, ties are resolved \n#'                               stochastically by randomly picking a sequence out of sequences \n#'                               with the maximal/minimal mutation frequency.\n#'                         \\item When \\code{breakTiesByColumns} is supplied, ties are resolved\n#'                               deterministically. Column by column, a function is applied on \n#'                               the column and sequences with column value matching the \n#'                               functional value are retained, until ties are resolved or columns\n#'                               run out. In the latter case, the first remaining sequence is \n#'                               taken as the consensus.\n#'                         \\item When \\code{breakTiesStochastic=TRUE} and \\code{breakTiesByColumns} \n#'                               is also supplied, \\code{breakTiesStochastic} takes precedence \n#'                               over \\code{breakTiesByColumns}.\n#'                         \\item When \\code{breakTiesStochastic=FALSE} and \\code{breakTiesByColumns} \n#'                               is not supplied (i.e. \\code{NULL}), the sequence that appears first\n#'                               amongst the ties is taken as the consensus.\n#'                    }\n#'          \n#'          }\n#'          \n#' \n#' @section Choosing ambiguous characters: \n#'          \n#'          Ambiguous characters may be present in the returned consensuses when using the\n#'          \\code{\"catchAll\"} method and when using the \\code{\"thresholdedFreq\"} or \n#'          \\code{\"mostCommon\"} methods with \\code{includeAmbiguous=TRUE}. \n#'          \n#'          The rules on choosing ambiguous characters are as follows:\n#'          \n#'          \\itemize{\n#'               \\item If a position contains only \\code{\"N\"} across sequences, the consensus \n#'                     at that position is \\code{\"N\"}.\n#'               \\item If a position contains one or more of \\code{\"A\"}, \\code{\"T\"}, \\code{\"G\"}, \n#'                     or \\code{\"C\"}, the consensus will be an IUPAC character representing all \n#'                     of the characters present, regardless of whether \\code{\"N\"}, \\code{\"-\"}, or\n#'                     \\code{\".\"} is present.\n#'               \\item If a position contains only \\code{\"-\"} and \\code{\".\"} across sequences, \n#'                     the consensus at thatp osition is taken to be \\code{\"-\"}. \n#'               \\item If a position contains only one of \\code{\"-\"} or \\code{\".\"} across \n#'                     sequences, the consensus at that position is taken to be the character \n#'                     present. \n#'          }\n#' \n#' @section Cautions: \n#' \n#'          \\itemize{\n#'               \\item   Note that this function does not perform multiple sequence alignment. \n#'                       As a prerequisite, it is assumed that the sequences in \n#'                       \\code{sequenceColumn} and \\code{germlineColumn} have been aligned somehow. \n#'                       In the case of immunoglobulin repertoire analysis, this usually means that \n#'                       the sequences are IMGT-gapped.\n#'               \\item   When using the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods, \n#'                       if you supply both \\code{muFreqColumn} and \\code{regionDefinition},\n#'                       it is your responsibility to ensure that the mutation frequency in\n#'                       \\code{muFreqColumn} was calculated with sequence lengths restricted \n#'                       to the \\strong{same} \\code{regionDefinition} you are supplying. Otherwise, \n#'                       the \"most/least mutated\" sequence you obtain might not be the most/least \n#'                       mutated given the \\code{regionDefinition} supplied, because your mutation\n#'                       frequency was based on a \\code{regionDefinition} different from the one \n#'                       supplied.\n#'               \\item   If you intend to run \\code{collapseClones} before \n#'                       building a 5-mer targeting model, you \\strong{must} choose \n#'                       parameters such that your collapsed clonal consensuses do \n#'                       \\strong{not} include ambiguous characters. This is because the \n#'                       targeting model functions do NOT support ambiguous characters \n#'                       in their inputs.\n#'               }\n#' \n#' @seealso\n#' See \\link{IMGT_SCHEMES} for a set of predefined \\link{RegionDefinition} objects.\n#' \n#' @examples\n#' # Subset example data\n#' data(ExampleDb, package=\"alakazam\")\n#' db <- subset(ExampleDb, ISOTYPE %in% c(\"IgA\", \"IgG\") & SAMPLE == \"+7d\" &\n#'                         CLONE %in% c(\"3100\", \"3141\", \"3184\"))\n#' # make a copy of db that has a mutation frequency column\n#' db2 <- observedMutations(db, frequency=TRUE, combine=TRUE)\n#' \n#' # Build clonal consensus for the full sequence\n#' \n#' # thresholdedFreq method, resolving ties deterministically without using ambiguous characters\n#' clones1 <- collapseClones(db, method=\"thresholdedFreq\", minimumFrequency=0.6,\n#'                           includeAmbiguous=FALSE, breakTiesStochastic=FALSE)\n#' # thresholdedFreq method, resolving ties deterministically using ambiguous characters\n#' clones2 <- collapseClones(db, method=\"thresholdedFreq\", minimumFrequency=0.6,\n#'                           includeAmbiguous=TRUE, breakTiesStochastic=FALSE)\n#' # thresholdedFreq method, resolving ties stochastically\n#' clones3 <- collapseClones(db, method=\"thresholdedFreq\", minimumFrequency=0.6,\n#'                           includeAmbiguous=FALSE, breakTiesStochastic=TRUE)\n#' \n#' # mostCommon method, resolving ties deterministically without using ambiguous characters\n#' clones4 <- collapseClones(db, method=\"mostCommon\", \n#'                           includeAmbiguous=FALSE, breakTiesStochastic=FALSE)\n#' # mostCommon method, resolving ties deterministically using ambiguous characters\n#' clones5 <- collapseClones(db, method=\"mostCommon\", \n#'                           includeAmbiguous=TRUE, breakTiesStochastic=FALSE)\n#' # mostCommon method, resolving ties stochastically\n#' clones6 <- collapseClones(db, method=\"mostCommon\", \n#'                           includeAmbiguous=FALSE, breakTiesStochastic=TRUE)\n#' \n#' # catchAll method\n#' clones7 <- collapseClones(db, method=\"catchAll\")\n#' \n#' # mostMutated method, resolving ties stochastically\n#' clones8 <- collapseClones(db, method=\"mostMutated\", muFreqColumn=NULL, \n#'                           breakTiesStochastic=TRUE, breakTiesByColumns=NULL)\n#' clones9 <- collapseClones(db2, method=\"mostMutated\", muFreqColumn=\"MU_FREQ\", \n#'                           breakTiesStochastic=TRUE, breakTiesByColumns=NULL)\n#' # mostMutated method, resolving ties deterministically using additional columns\n#' clones10 <- collapseClones(db, method=\"mostMutated\", muFreqColumn=NULL, \n#'                            breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n#' clones11 <- collapseClones(db2, method=\"mostMutated\", muFreqColumn=\"MU_FREQ\", \n#'                            breakTiesStochastic=FALSE, \n#'                            breakTiesByColumns=list(c(\"DUPCOUNT\"), c(max)))\n#' # mostMutated method, resolving ties deterministically without using additional columns\n#' clones12 <- collapseClones(db, method=\"mostMutated\", muFreqColumn=NULL, \n#'                            breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n#' clones13 <- collapseClones(db2, method=\"mostMutated\", muFreqColumn=\"MU_FREQ\", \n#'                            breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n#' \n#' \n#' # Build clonal consensus for V-region only\n#' clones14 <- collapseClones(db, method=\"mostCommon\", regionDefinition=IMGT_V)\n#' \n#' # Return the same number of rows as the input\n#' clones15 <- collapseClones(db, method=\"mostCommon\", expandedDb=TRUE)\n#' \n#' @export\ncollapseClones <- function(db, \n                           cloneColumn=\"CLONE\", \n                           sequenceColumn=\"SEQUENCE_IMGT\",\n                           germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n                           muFreqColumn=NULL,\n                           regionDefinition=NULL,\n                           method=c(\"mostCommon\", \"thresholdedFreq\", \"catchAll\", \"mostMutated\", \"leastMutated\"),\n                           minimumFrequency=NULL,\n                           includeAmbiguous=FALSE,\n                           breakTiesStochastic=FALSE,\n                           breakTiesByColumns=NULL,\n                           expandedDb=FALSE,\n                           nproc=1) {\n    # Hack for visibility of foreach index variables\n    idx <- NULL\n    \n    ## DEBUG\n    # cloneColumn=\"CLONE\"; sequenceColumn=\"SEQUENCE_IMGT\"; germlineColumn=\"GERMLINE_IMGT_D_MASK\"\n    # expandedDb=FALSE; regionDefinition=NULL; method=\"mostCommon\"; nproc=1\n    \n    #### parameter checks\n    \n    method = match.arg(method)\n    \n    # check minimumFrequency for thresholdedFreq method\n    if (method==\"thresholdedFreq\") {\n        if (!is.numeric(minimumFrequency)) {\n            stop(\"minimumFrequency must be a numeric value.\")\n        } else {\n            if ( minimumFrequency<0 | minimumFrequency>1 ) {\n                stop(\"minimumFrequency must be between 0 and 1.\")\n            }\n        }\n    }\n    \n    # check includeAmbiguous & breakTiesStochastic for methods other than catchAll\n    if (method %in% c(\"thresholdedFreq\", \"mostCommon\", \"mostMutated\", \"leastMutated\")) {\n        if (class(includeAmbiguous) != \"logical\") {\n            stop (\"includeAmbiguous must be TRUE or FALSE.\")\n        }\n        if (class(breakTiesStochastic) != \"logical\") {\n            stop (\"breakTiesStochastic must be TRUE or FALSE.\")\n        }\n    }\n    \n    # check breakTiesByColumns and muFreqColumn for methods most/leastMutated\n    if (method %in% c(\"mostMutated\", \"leastMutated\")) {\n        \n        if (!is.null(breakTiesByColumns)) {\n            if (class(breakTiesByColumns) != \"list\") {\n                stop (\"breakTiesByColumns must be a list.\")\n            }\n            if (length(breakTiesByColumns) != 2) {\n                stop (\"breakTiesByColumns must be a nested list of length 2.\")\n            }\n            if ( length(breakTiesByColumns[[1]]) != length(breakTiesByColumns[[2]]) ) {\n                stop (\"Nested vectors in breakTiesByColumns must have the same lengths.\")\n            }\n            if ( !all(is.character(breakTiesByColumns[[1]])) ) {\n                stop (\"The first vector in breakTiesByColumns must contain column names.\")\n            }\n            if ( !all( unlist( lapply(breakTiesByColumns[[2]], is.function) ) ) ) {\n                stop (\"The second vector in breakTiesByColumns must contain functions.\")\n            }\n            if ( !all(breakTiesByColumns[[1]] %in% colnames(db)) ) {\n                stop (\"All column named included in breakTiesByColumns must be present in db.\")\n            }\n        }\n        \n        if ( (!is.null(muFreqColumn)) && (!muFreqColumn %in% colnames(db)) ) {\n            stop (\"If specified, muFreqColumn must be a column present in db.\")\n        }\n    }\n    \n    # check mutual exclusivitiy\n    if (method %in% c(\"thresholdedFreq\", \"mostCommon\")){\n        if (includeAmbiguous & breakTiesStochastic) {\n            message(\"includeAmbiguous and breakTiesStochastic are mutually exclusive. When both TRUE, includeAmbiguous will take precedence.\")\n        }\n        if ( (!includeAmbiguous) & (!breakTiesStochastic) ) {\n            message(\"When both includeAmbiguous and breakTiesStochastic are FALSE, ties are broken in the order of 'A', 'T', 'G', 'C', 'N', '.', and '-'.\")\n        }\n        if (!is.null(breakTiesByColumns)) {\n            message(\"breakTiesByColumns is ignored when method is thresholdedFreq or mostCommon.\")\n        }\n    }\n    \n    if (method %in% c(\"mostMutated\", \"leastMutated\")){\n        if (breakTiesStochastic & !is.null(breakTiesByColumns)) {\n            message(\"breakTiesStochastic and breakTiesByColumns are mutually exclusive. When both set, breakTiesStochastic will take precedence.\")\n        }\n        if ( (!breakTiesStochastic) & is.null(breakTiesByColumns) ) {\n            message(\"When breakTiesStochastic is FALSE and breakTiesByColumns is NULL, ties are broken by taking the sequence that appears earlier in the data.frame.\")\n        }\n        if (includeAmbiguous) {\n            message(\"includeAmbiguous is ignored when method is mostMutated or leastMutated.\")\n        }\n    }\n    \n    # Check for valid columns\n    check <- checkColumns(db, c(cloneColumn, sequenceColumn, germlineColumn))\n    if (check != TRUE) { stop(check) }\n    \n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    ### Convert sequence columns to uppercase\n    db <- toupperColumns(db, c(sequenceColumn, germlineColumn))\n    \n    # If the user has previously set the cluster and does not wish to reset it\n    if(!is.numeric(nproc)){ \n        cluster = nproc \n        nproc = 0\n    }\n    \n    if (class(expandedDb) != \"logical\") {\n        stop (\"expandedDb must be TRUE or FALSE.\")\n    }\n    \n    # Convert clone identifiers to strings\n    db[[cloneColumn]] <- as.character(db[[cloneColumn]])\n    \n    # get row indices in db for each unique clone\n    uniqueClones = unique(db[[cloneColumn]])\n    # crucial to have simplify=FALSE (otherwise won't return a list if uniqueClones has length 1)\n    uniqueClonesIdx = sapply(uniqueClones, function(i){which(db[[cloneColumn]]==i)}, simplify=FALSE)\n    \n    # if method is most/leastMutated and muFreqColumn not specified,\n    # first calculate mutation frequency ($MU_FREQ)\n    # IMPORTANT: do this OUTSIDE foreach loop for calcClonalConsensus\n    # otherwise will get an error saying muFreqColumn not found in db\n    # (something to do with parallelization/foreach)\n    if ( (method %in% c(\"mostMutated\", \"leastMutated\")) & is.null(muFreqColumn) ) {\n        message(\"Calculating observed mutation frequency...\")\n        db <- observedMutations(db=db, sequenceColumn=sequenceColumn,\n                                germlineColumn=germlineColumn, \n                                regionDefinition=regionDefinition,\n                                frequency=TRUE, combine=TRUE, \n                                mutationDefinition=NULL, nproc=nproc)\n        muFreqColumn <- \"MU_FREQ\"\n    }\n    \n    # Ensure that the nproc does not exceed the number of cores/CPUs available\n    nproc <- min(nproc, getnproc())\n    \n    # If user wants to paralellize this function and specifies nproc > 1, then\n    # initialize and register slave R processes/clusters & \n    # export all nesseary environment variables, functions and packages.\n    if (nproc == 1) {\n        # If needed to run on a single core/cpu then, regsiter DoSEQ \n        # (needed for 'foreach' in non-parallel mode)\n        registerDoSEQ()\n    } else {\n        if (nproc != 0) { \n            #cluster <- makeCluster(nproc, type=\"SOCK\") \n            cluster <- parallel::makeCluster(nproc, type= \"PSOCK\")\n        }\n        parallel::clusterExport(cluster, \n                                list('db', 'cloneColumn', 'sequenceColumn', 'germlineColumn', 'muFreqColumn',\n                                     'regionDefinition', 'method', 'minimumFrequency','includeAmbiguous',\n                                     'breakTiesStochastic', 'breakTiesByColumns', \n                                     'calcClonalConsensus', 'calcClonalConsensusHelper', 'breakTiesHelper',\n                                     'chars2Ambiguous', 'nucs2IUPAC', 'IUPAC_DNA_2',  'NUCLEOTIDES_AMBIGUOUS',\n                                     'uniqueClonesIdx', 'c2s', 's2c'), \n                                envir=environment() )\n        registerDoParallel(cluster)\n    }\n    \n    # Printing status to console\n    cat(\"Collapsing clonal sequences...\\n\")\n    \n    # avoid .combine=\"cbind\"!\n    # if there is only 1 unique clone, .combind=\"cbind\" will result in a vector (as opposed to\n    # a matrix) being returned, which will subsequently result a failure in\n    # cons_db$CLONAL_SEQUENCE <- cons_mat[, 1]\n    cons_mat <- foreach(idx=1:length(uniqueClonesIdx),\n                        .verbose=FALSE, .errorhandling='stop') %dopar% {\n                            \n                            cloneIdx <- uniqueClonesIdx[[idx]]\n                            cloneDb <- db[cloneIdx, ]\n                            \n                            # collapse clone\n                            calcClonalConsensus(db=cloneDb,\n                                                sequenceColumn=sequenceColumn,\n                                                germlineColumn=germlineColumn,\n                                                muFreqColumn=muFreqColumn,\n                                                regionDefinition=regionDefinition,\n                                                method=method,\n                                                minimumFrequency=minimumFrequency,\n                                                includeAmbiguous=includeAmbiguous,\n                                                breakTiesStochastic=breakTiesStochastic,\n                                                breakTiesByColumns=breakTiesByColumns)\n                        }\n    # using cbind below will give a matrix with columns being clones\n    # use rbind to have rows be clones\n    # cols: inputCons, germlineCons, inputMuFreq\n    cons_mat <- do.call(rbind, cons_mat)\n    \n    # Stop cluster\n    if(nproc > 1) { parallel::stopCluster(cluster) }\n    \n    # Build return data.frame\n    if (expandedDb) { \n        # Fill all rows with the consensus sequence\n        clone_index <- match(db[[cloneColumn]], uniqueClones)\n        cons_db <- db\n        cons_db$CLONAL_SEQUENCE <- unlist(cons_mat[, 1])[clone_index]\n        cons_db$CLONAL_GERMLINE <- unlist(cons_mat[, 2])[clone_index]\n        \n        # assign mutation frequency corresponding to consensus into CLONAL_SEQUENCE_MUFREQ\n        if (method %in% c(\"mostMutated\", \"leastMutated\")) {\n            cons_db$CLONAL_SEQUENCE_MUFREQ = unlist(cons_mat[, 3])[clone_index]\n        }\n    } else {\n        # Return only the first row of each clone\n        clone_index <- match(uniqueClones, db[[cloneColumn]])\n        cons_db <- db[clone_index, ]\n        cons_db$CLONAL_SEQUENCE <- unlist(cons_mat[, 1])\n        cons_db$CLONAL_GERMLINE <- unlist(cons_mat[, 2])\n        \n        # assign mutation frequency corresponding to consensus into CLONAL_SEQUENCE_MUFREQ\n        if (method %in% c(\"mostMutated\", \"leastMutated\")) {\n            cons_db$CLONAL_SEQUENCE_MUFREQ = unlist(cons_mat[, 3])\n        }\n    }\n    \n    return(cons_db)\n}\n\n\n# Break ties given additional columns in db and functions to compute on them\n#\n# @param     idx     vector of indices.\n# @param     cols    character vector of colnames. Currently, only columns containing\n#                    numeric values are supported/expected.\n# @param     funs    list of functions. Currently, only \\code{max} and \\code{min} are \n#                    supported/expected.\n# @param     db      \\code{data.frame} containing columns named after \\code{cols} with \n#                    corresponding rows for \\code{idx}.\n#\n# @return    a single value from \\code{idx}.\n# \n# @details   Column by column, \\code{breakTiesHelper} calls the corresponding function\n#            from \\code{funs} on a column in \\code{db} and finds the index/indices in \n#            \\code{idx} that match(es) the returned value from the function. This stops\n#            when only a single matching index is obtained, or columns run out. In the \n#            latter case, the first remaining index is returned.\n#\n# testing\n# expect index 18\n# test.idx = c(2,4,18,37,102,76)\n# test.db = data.frame(cbind(DUPCOUNT= c(3,5,5,4,5,1),\n#                            CONSCOUNT=c(6,6,6,2,3,4), \n#                            ERR=c(0.9, 0.14, 0.12, 0.07, 0.3, 0.5)))\n# test.cols = c(\"DUPCOUNT\", \"CONSCOUNT\", \"ERR\")\n# test.funs = c(max, max, min)\n# stopifnot( breakTiesHelper(test.idx, test.cols, test.funs, test.db)==18 )\n# # make index 4 and 18 tie for ERR\n# # index 4 is expected because it appears before 18\n# test.db[3,\"ERR\"] = 0.14\n# stopifnot( breakTiesHelper(test.idx, test.cols, test.funs, test.db)==4 )\n#\nbreakTiesHelper = function(idx, cols, funs, db) {\n    # debug\n    # idx=test.idx; cols=test.cols; funs=test.funs; db=test.db\n    \n    counter = 1\n    while (length(idx)>1 & counter<=length(cols)) {\n        cur.col = cols[counter]\n        cur.fun = funs[[counter]]\n        cur.db = db[[cur.col]]\n        \n        target = cur.fun(cur.db)\n        tol = 1e-5 # tolerance\n        target.idx = which( abs(cur.db-target)<=tol ) # wrt idx & db\n        \n        idx = idx[target.idx]\n        db = db[target.idx, ]\n        counter = counter+1\n    }\n    \n    if (length(idx)==1) {\n        return(idx)\n    } else if (length(idx)>1) {\n        #print(\"Failed to resolve ties.\") # for testing/debugging\n        return(idx[1])\n    } else {\n        stop(\"breakTieHelper failed unexpectedly.\")\n    }\n}\n\n# Helper function for calcClonalConsensus\n#\n# @param   seqs                 a character vector of sequences.\n# @param   muFreqColumn         \\code{character} name of the column in db containing mutation\n#                               frequency. Applicable to and required for the \\code{\"mostMutated\"} \n#                               and \\code{\"leastmutated\"} methods. Default is \\code{NULL}. \n# @param   lenLimit             limit on consensus length. \n# @param   mtd                  method to calculate consensus sequence. One of \n#                               \\code{\"thresholdedFreq\"}, \\code{\"mostCommon\"}, \\code{\"catchAll\"},\n#                               \\code{\"mostMutated\"}, or \\code{\"leastMutated\"}. See \"Methods\" under\n#                               \\link{collapseClones} for details.\n# @param   minFreq              frequency threshold for calculating input consensus sequence.\n#                               Applicable to and required for the \\code{\"thresholdedFreq\"} method. \n#                               A canonical choice is 0.6. Default is \\code{NULL}.\n# @param   includeAmbiguous     whether to use ambiguous characters to represent positions at\n#                               which there are multiple characters with frequencies that are at least\n#                               \\code{minimumFrequency} or that are maximal (i.e. ties). Applicable to \n#                               and required for the \\code{\"thresholdedFreq\"} and \\code{\"mostCommon\"} \n#                               methods. Default is \\code{FALSE}. See \"Choosing ambiguous characters\" \n#                               under \\link{collapseClones} for rules on choosing ambiguous characters. \n# @param   breakTiesStochastic  In case of ties, whether to randomly pick a sequence from sequences that\n#                               fulfill the criteria as consensus. Applicable to and required for all methods\n#                               except for \\code{\"catchAll\"}. Default is \\code{FALSE}. See \"Methods\" \n#                               under \\link{collapseClones} for details. \n# @param   breakTiesByColumns   A list of the form \\code{list(c(col_1, col_2, ...), c(fun_1, fun_2, ...))}, \n#                               where \\code{col_i} is a \\code{character} name of a column in \\code{db},\n#                               and \\code{fun_i} is a function to be applied on that column. Currently, \n#                               only \\code{max} and \\code{min} are supported. Note that the two \\code{c()}'s\n#                               in \\code{list()} are essential (i.e. if there is only 1 column, the list \n#                               should be of the form \\code{list(c(col_1), c(func_1))}. Applicable to and \n#                               optional for the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods. \n#                               If supplied, \\code{fun_i}'s are applied on \\code{col_i}'s to help break \n#                               ties. Default is \\code{NULL}. See \"Methods\" under \\link{collapseClones} \n#                               for details.                                                  \n# @param   db                   \\code{data.frame} containing sequence data for a single clone. \n#                               Applicable to and required for the \\code{\"mostMutated\"} and \n#                               \\code{\"leastmutated\"} methods. Default is \\code{NULL}.\n#\n# @return  A list containing \\code{cons}, which is a character string that is the consensus sequence \n#          for \\code{seqs}; and \\code{muFreq}, which is the maximal/minimal mutation frequency of\n#          the consensus sequence for the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods, or\n#          \\code{NULL} for all other methods.\n#\n# @details See \\link{collapseClones} for detailed documentation on methods and additional parameters.\n# \n# @seealso\n# \\link{calcClonalConsensus} and \\link{collapseClones}.\n# \n# @examples\n# Subset example data\n# data(ExampleDb, package=\"alakazam\")\n# db <- subset(ExampleDb, ISOTYPE %in% c(\"IgA\", \"IgG\") & SAMPLE == \"+7d\")\n# \n# Data corresponding to a single clone\n# clone <- db[db$CLONE==\"3192\", ]\n# Number of sequences in this clone\n# nrow(clone)\n# first compute mutation frequency for most/leastMutated methods\n# clone = observedMutations(db=clone, frequency=TRUE, combine=TRUE)\n# manually create tie\n# clone = rbind(clone, clone[which.max(clone$MU_FREQ), ])\n# \n# Get consensus input sequence\n# thresholdedFreq method, resolve ties deterministically without using ambiguous characters\n# consInput1 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"thresholdedFreq\", minFreq=0.3,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# thresholdedFreq method, resolve ties deterministically using ambiguous characters\n# consInput2 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"thresholdedFreq\", minFreq=0.3,\n#                                         includeAmbiguous=TRUE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# thresholdedFreq method, resolve ties stochastically\n# consInput3 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"thresholdedFreq\", minFreq=0.3,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=TRUE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# mostCommon method, resolve ties deterministically without using ambiguous characters\n# consInput4 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"mostCommon\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# mostCommon method, resolve ties deterministically using ambiguous characters\n# consInput5 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"mostCommon\", minFreq=NULL,\n#                                         includeAmbiguous=TRUE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# mostCommon method, resolve ties stochastically\n# consInput6 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"mostCommon\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=TRUE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# catchAll method\n# consInput7 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=NULL, lenLimit=NULL,\n#                                         mtd=\"catchAll\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=NULL, db=NULL)$cons\n# mostMutated method, resolve ties stochastically\n# consInput8 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=\"MU_FREQ\", lenLimit=NULL,\n#                                         mtd=\"mostMutated\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=TRUE,\n#                                         breakTiesByColumns=NULL, db=clone)$cons\n# mostMutated method, resolve ties deterministically using additional columns\n# consInput9 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=\"MU_FREQ\", lenLimit=NULL,\n#                                         mtd=\"mostMutated\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=list(c(\"JUNCTION_LENGTH\",\"DUPCOUNT\"), c(max, max)), \n#                                         db=clone)$cons\n# consInput10 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                         muFreqColumn=\"MU_FREQ\", lenLimit=NULL,\n#                                         mtd=\"mostMutated\", minFreq=NULL,\n#                                         includeAmbiguous=FALSE, \n#                                         breakTiesStochastic=FALSE,\n#                                         breakTiesByColumns=list(c(\"DUPCOUNT\"), c(max)), \n#                                         db=clone)$cons\n# mostMutated method, resolve ties deterministically withou using additional columns\n# consInput11 <- calcClonalConsensusHelper(seqs=clone$SEQUENCE_IMGT,\n#                                          muFreqColumn=\"MU_FREQ\", lenLimit=NULL,\n#                                          mtd=\"mostMutated\", minFreq=NULL,\n#                                          includeAmbiguous=FALSE, \n#                                          breakTiesStochastic=FALSE,\n#                                          breakTiesByColumns=NULL, db=clone)$cons\n# \ncalcClonalConsensusHelper = function(seqs, muFreqColumn=NULL, lenLimit=NULL,\n                                     mtd=c(\"mostCommon\", \"thresholdedFreq\", \"catchAll\", \"mostMutated\", \"leastMutated\"),\n                                     minFreq=NULL,\n                                     includeAmbiguous=FALSE,\n                                     breakTiesStochastic=FALSE,\n                                     breakTiesByColumns=NULL, db=NULL) {\n    mtd = match.arg(mtd)\n    \n    # check muFreqColumn and get muFreq for most/leastMutated\n    if (mtd %in% c(\"mostMutated\", \"leastMutated\")) {\n        if ( is.null(muFreqColumn) ) {\n            stop (\"muFreqColumn must be specified when method is most/leastMutated.\")\n        }\n        if ( is.null(db) ) {\n            stop (\"db containing muFreqColumn must be supplied when method is most/leastMutated.\")\n        }\n        if (!muFreqColumn %in% colnames(db)) {\n            print(c(\"Helper\", muFreqColumn))\n            print(c(\"Helper\", colnames(db)))\n            stop (\"muFreqColumn must be a column present in db.\")\n        }\n        \n        # get muFreq\n        muFreq = db[[muFreqColumn]]\n    }\n    \n    \n    numSeqs = length(seqs)\n    \n    ##### if only one sequence in clone, return it\n    if (numSeqs==1) {\n        # restrict length if there is a lenLimit\n        if (!is.null(lenLimit)) {\n            consensus = substr(seqs, 1, min(lenLimit, nchar(seqs)))\n        } else {\n            # otherwise, return as is\n            consensus = seqs\n        }\n        \n        # return with mutation frequency (if applicable)\n        if (mtd %in% c(\"mostMutated\", \"leastMutated\")) {\n            return(list(cons=consensus, muFreq=db[[muFreqColumn]]))\n        } else {\n            return(list(cons=consensus, muFreq=NULL))\n        }\n    }\n    \n    ##### if all sequences are the same, return now\n    if (length(unique(seqs))==1) {\n        # restrict length if there is a lenLimit\n        if (!is.null(lenLimit)) {\n            consensus = substr(seqs[1], 1, min(lenLimit, nchar(seqs)))\n        } else {\n            # otherwise, return as is\n            consensus = seqs[1]\n        }\n        \n        # return with mutation frequency (if applicable)\n        if (mtd %in% c(\"mostMutated\", \"leastMutated\")) {\n            return(list(cons=consensus, muFreq=db[[muFreqColumn]][1]))\n        } else {\n            return(list(cons=consensus, muFreq=NULL))\n        }\n    }\n    \n    ##### length of longest sequence in seqs\n    lenSeqs = nchar(seqs)\n    lenMax = max(lenSeqs, na.rm=T)\n    \n    ##### methods = thresholdedFreq, mostCommon, catchAll\n    if (mtd %in% c(\"thresholdedFreq\", \"mostCommon\", \"catchAll\")) {\n        ##### convert seqs to a matrix\n        # if there's no more nucleotide when a seq ends, fill position with NA\n        seqsMtx = matrix(NA, nrow=numSeqs, ncol=lenMax)\n        for (i in 1:numSeqs) {\n            seqsMtx[i, 1:lenSeqs[i]] = s2c(seqs[i])\n        }\n        \n        ##### tabulation matrix\n        # col: nucleotide position\n        # row: A,T,G,C,N,.,-,na (to distinguish from NA)\n        tabMtxRownames = c(\"A\",\"T\",\"G\",\"C\",\"N\",\".\",\"-\",\"na\")\n        tabMtx = matrix(0, ncol=lenMax, nrow=8, \n                        dimnames=list(tabMtxRownames, NULL))\n        ## across seqs, at each nuc position, how many A, T, G, C, N, ., -? \n        # this does not capture NA\n        for (j in 1:ncol(seqsMtx)) {\n            tab = table(seqsMtx[, j])\n            tabMtx[match(names(tab), tabMtxRownames), j] = tab\n        }\n        ## across seqs, at each nuc position, how many NAs?\n        numNAs = colSums(is.na(seqsMtx))\n        tabMtx[\"na\", ] = numNAs\n        # sanity check: counts at each nuc pos (colSum) should sum up to number of seqs\n        stopifnot( sum( colSums(tabMtx)==numSeqs )  == ncol(tabMtx)  )\n        \n        ##### only keep positions at which majority of seqs contain information\n        ### if there are odd number of n seqs, keep position if it has > floor(n/2) non-NAs\n        # e.g. 5 input seqs, >2 non-NA; 2=floor(5/2)\n        ### if there are even number of n seqs,  keep position if it has > n/2 non-NAs\n        # e.g. 6 input seqs, >3 non-NA; 3=6/2=floor(6/2)\n        numNonNAs = numSeqs - numNAs\n        nonNA.keep = numNonNAs > floor(numSeqs/2)\n        # length of longest possible consensus seq\n        lenConsensus = sum(nonNA.keep)\n        if (lenConsensus==0) {\n            warning(\"Consensus cannot be produced. Empty string returned.\")\n            return(\"\")\n        }\n        ##### if there is a lenLimit, restrict consensus length to \n        # the shorter of longest possible length and lenLimit\n        if (!is.null(lenLimit)) {\n            lenConsensus = min(lenConsensus, lenLimit)\n        }\n        # drop=FALSE so that it works even with lenConsensus of 1\n        tabMtx = tabMtx[, 1:lenConsensus, drop=FALSE]\n        \n        ### convert absolute count to fraction\n        tabMtx = tabMtx/numSeqs\n        # remove \"na\" row\n        # drop=FALSE so that it works even with lenConsensus of 1\n        tabMtx = tabMtx[-which(rownames(tabMtx)==\"na\"), , drop=FALSE]\n        \n        if (mtd==\"thresholdedFreq\") {\n            #print(mtd) # for testing\n            # use as.matrix so that apply won't break with ncol(tabMtx)=1\n            consensus = apply(as.matrix(tabMtx), 2, function(x){\n                idx = which(x >= minFreq)\n                # if no character >= the threshold, assign an N\n                if (length(idx)==0) {\n                    return(\"N\")\n                    # if there is no tie\n                } else if (length(idx)==1){\n                    return(names(x)[idx])\n                    # if there are ties (multiple characters >= the threhold)\n                } else if (length(idx)>1) {\n                    # ambiguous character allowed\n                    if (includeAmbiguous) {\n                        return(chars2Ambiguous(tabMtxRownames[idx]))\n                        # ambiguous characters not allowed\n                    } else {\n                        # stochastic\n                        if (breakTiesStochastic) {\n                            return(names(x)[sample(x=idx, size=1)])\n                            # first one is returned\n                            # the order is built-in from tabMtxRownames\n                        } else {\n                            return(names(x)[idx[1]])\n                        }\n                    }\n                }\n            })\n        } else if (mtd==\"mostCommon\") { \n            #print(mtd) # for testing\n            # use as.matrix so that apply won't break with ncol(tabMtx)=1\n            consensus = apply(as.matrix(tabMtx), 2, function(x){\n                max.freq = max(x)\n                tol = 1e-5 # tolerance\n                max.idx = which( abs(x-max.freq)<=tol )\n                \n                # if there is no tie\n                if (length(max.idx)==1){\n                    return(names(x)[max.idx])\n                    # if there are ties (multiple characters with maximal frequency)\n                } else if (length(max.idx)>1) {\n                    # ambiguous character allowed\n                    if (includeAmbiguous) {\n                        return(chars2Ambiguous(tabMtxRownames[max.idx]))\n                        # ambiguous characters not allowed\n                    } else {\n                        # stochastic\n                        if (breakTiesStochastic) {\n                            return(names(x)[sample(x=max.idx, size=1)])\n                            # first one is returned\n                            # the order is built-in from tabMtxRownames\n                        } else {\n                            return(names(x)[max.idx[1]])\n                        }\n                    }\n                }\n            })\n        } else if (mtd==\"catchAll\") {\n            #print(mtd) # for testing\n            # use as.matrix so that apply won't break with ncol(tabMtx)=1\n            consensus = apply(as.matrix(tabMtx), 2, function(x){\n                # all characters that appear at a position across seqs\n                nonZeroNucs = rownames(tabMtx)[x>0]\n                # convert characters to (ambiguous) characters\n                return(chars2Ambiguous(nonZeroNucs))\n            })\n        }\n        \n        # check there is no ambiguous characters if includeAmbiguous if F \n        if ( (mtd==\"thresholdedFreq\" | mtd==\"mostCommon\") & !includeAmbiguous ) {\n            ambiguous = NUCLEOTIDES_AMBIGUOUS[!NUCLEOTIDES_AMBIGUOUS %in% \n                                                  c(\"A\",\"C\",\"G\",\"T\",\"N\",\"-\",\".\")]\n            stopifnot( !any(consensus %in% ambiguous) )\n        }\n        \n        # convert from character vector to string\n        consensus = c2s(consensus)\n        # sanity check\n        stopifnot( nchar(consensus)==lenConsensus )\n    }\n    \n    ##### methods = mostMutated, leastMutated\n    if (mtd %in% c(\"mostMutated\", \"leastMutated\")) {\n        # if there's a lenLimit\n        # if a seq is longer than lenLimit, trim it; otherwise, leave it as is\n        if (!is.null(lenLimit)) {\n            idxLong = which(lenSeqs > lenLimit)\n            seqs[idxLong] = substr(seqs[idxLong], 1, lenLimit)\n        }\n        \n        ##### get index of seqs that fulfill the criterion\n        # muFreq should have been calculated being on sequences with restricted lengths as defined by\n        # regionDefinition (which gives rise to lenLimit)\n        if (mtd==\"mostMutated\") {\n            #print(mtd) # for testing\n            targetMuFreq = max(muFreq)\n        } else if (mtd==\"leastMutated\") {\n            #print(mtd) # for testing\n            targetMuFreq = min(muFreq)\n        }\n        tol = 1e-5 # tolerance\n        idx = which( abs(muFreq-targetMuFreq)<=tol )\n        \n        ##### if there are no ties\n        if (length(idx)==1) {\n            consensus = seqs[idx]\n            ##### if there are ties\n        } else if (length(idx)>1) {\n            \n            ### stochastic: randomly pick one from idx\n            if (breakTiesStochastic) {\n                consensus = seqs[sample(x=idx, size=1)]\n                \n                ### deterministic: pick one from idx based on breakTiesByColumns    \n            } else if (!is.null(breakTiesByColumns)) {\n                idx = breakTiesHelper(idx=idx, cols=breakTiesByColumns[[1]], \n                                      funs=breakTiesByColumns[[2]], db=db[idx, ])\n                consensus = seqs[idx]\n                \n                ### deterministic: pick first one from idx    \n            } else {\n                consensus = seqs[idx[1]]\n            }\n        }\n        \n    }\n    \n    # check length\n    if (!is.null(lenLimit)) {\n        stopifnot(nchar(consensus) <= lenLimit)\n    }\n    \n    if (mtd %in% c(\"mostMutated\", \"leastMutated\")) {\n        return(list(cons=consensus, muFreq=targetMuFreq))\n    } else {\n        return(list(cons=consensus, muFreq=NULL))\n    }\n}\n\n# Calculate clonal consensus for a single clone\n# \n# Given an aligned set of input/observed sequences and an aligned set of germline sequences, \n# generate an input/observed consensus and a germline consensus. \n#\n# @param   db                  \\code{data.frame} containing sequence data for a single clone. \n#                              Required.\n# @param   sequenceColumn      \\code{character} name of the column containing input \n#                              sequences. Required. The length of each input sequence should \n#                              match that of its corresponding germline sequence.\n# @param   germlineColumn      \\code{character} name of the column containing germline \n#                              sequences. Required. The length of each germline sequence should \n#                              match that of its corresponding input sequence.\n# @param   muFreqColumn        \\code{character} name of the column containing mutation\n#                              frequency. Applicable to and required for the \\code{\"mostMutated\"}\n#                              and \\code{\"leastMutated\"} methods. Default is \\code{NULL}. See \n#                              \"Details\" for a note of caution.\n# @param   regionDefinition    \\link{RegionDefinition} object defining the regions and boundaries \n#                              of the Ig sequences. Optional. Default is \\code{NULL}.\n# @param   method              method for calculating input consensus sequence. Required. One of \n#                              \\code{\"thresholdedFreq\"}, \\code{\"mostCommon\"}, \\code{\"catchAll\"},\n#                              \\code{\"mostMutated\"}, or \\code{\"leastMutated\"}. See \"Methods\" under\n#                              \\link{collapseClones} for details.\n# @param   minimumFrequency    frequency threshold for calculating input consensus sequence.\n#                              Applicable to and required for the \\code{\"thresholdedFreq\"} method. \n#                              A canonical choice is 0.6. Default is \\code{NULL}. \n# @param   includeAmbiguous    whether to use ambiguous characters to represent positions at\n#                              which there are multiple characters with frequencies that are at least\n#                              \\code{minimumFrequency} or that are maximal (i.e. ties). Applicable to \n#                              and required for the \\code{\"thresholdedFreq\"} and \\code{\"mostCommon\"} \n#                              methods. Default is \\code{FALSE}. See \"Choosing ambiguous characters\" \n#                              under \\link{collapseClones} for rules on choosing ambiguous characters. \n# @param   breakTiesStochastic In case of ties, whether to randomly pick a sequence from sequences that\n#                              fulfill the criteria as consensus. Applicable to and required for all methods\n#                              except for \\code{\"catchAll\"}. Default is \\code{FALSE}. See \"Methods\" \n#                              under \\link{collapseClones} for details. \n# @param   breakTiesByColumns  A list of the form \\code{list(c(col_1, col_2, ...), c(fun_1, fun_2, ...))}, \n#                              where \\code{col_i} is a \\code{character} name of a column in \\code{db},\n#                              and \\code{fun_i} is a function to be applied on that column. Currently, \n#                              only \\code{max} and \\code{min} are supported. Applicable to and optional for\n#                              the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods. If supplied, \n#                              \\code{fun_i}'s are applied on \\code{col_i}'s to help break ties. Default is \n#                              \\code{NULL}. See \"Methods\" under \\link{collapseClones} for details.                                                             \n#                              \n# @return  A named list of length 3. \"inputCons\" and \"germlineCons\" are the consensus sequences. \n#          The input and germline consensus sequences have the same length. \"inputMuFreq\" is the \n#          maximal/minimal mutation frequency for the input consensus for the \\code{\"mostMutated\"} \n#          and \\code{\"leastMutated\"} methods, and \\code{NULL} for all other methods.\n# \n# @details See \\link{collapseClones} for detailed documention on methods and additional parameters.\n# \n#          Caution: when using the \\code{\"mostMutated\"} and \\code{\"leastMutated\"} methods, if you \n#          supply a \\code{regionDefinition}, it is your responsibility to ensure that the mutation \n#          frequency in\\code{muFreqColumn} was calculated with sequence lengths restricted to the \n#          \\strong{same} \\code{regionDefinition} you are supplying. Otherwise, the \n#          \"most/least mutated\" sequence you obtain might not be the most/least mutated given the \n#          \\code{regionDefinition} supplied, because your mutation frequency was based on a \n#          \\code{regionDefinition} different from the one supplied.\n#                                       \n# @seealso\n# See \\link{collapseClones} for constructing consensus for all clones.\n# \n# @examples\n# # Subset example data\n# data(ExampleDb, package=\"alakazam\")\n# db <- subset(ExampleDb, ISOTYPE %in% c(\"IgA\", \"IgG\") & SAMPLE == \"+7d\")\n# \n# # Data corresponding to a single clone\n# clone <- db[db$CLONE==\"3192\", ]\n# # Number of sequences in this clone\n# nrow(clone)\n# # compute mutation frequency for most/leastMutated methods\n# clone = observedMutations(db=clone, frequency=TRUE, combine=TRUE)\n# # manually create a tie\n# clone = rbind(clone, clone[which.max(clone$MU_FREQ), ])\n# \n# # Get consensus input and germline sequences\n# # thresholdedFreq method, resolve ties deterministically without using ambiguous characters\n# cons1 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"thresholdedFreq\", \n#                              minimumFrequency=0.3, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n# # thresholdedFreq method, resolve ties deterministically using ambiguous characters\n# cons2 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"thresholdedFreq\", \n#                              minimumFrequency=0.3, includeAmbiguous=TRUE,\n#                              breakTiesStochastic=FALSE, breakTiesByColumns=NULL)  \n# # thresholdedFreq method, resolve ties stochastically\n# cons3 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"thresholdedFreq\", \n#                              minimumFrequency=0.3, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=TRUE, breakTiesByColumns=NULL)  \n# # mostCommon method, resolve ties deterministically without using ambiguous characters\n# cons4 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"mostCommon\", \n#                              minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n# # mostCommon method, resolve ties deterministically  using ambiguous characters\n# cons5 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"mostCommon\", \n#                              minimumFrequency=NULL, includeAmbiguous=TRUE,\n#                              breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n# # mostCommon method, resolve ties stochastically\n# cons6 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"mostCommon\", \n#                              minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=TRUE, breakTiesByColumns=NULL)\n# # catchAll method\n# cons7 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=NULL, regionDefinition=NULL,\n#                              method=\"catchAll\", \n#                              minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n# # mostMutated method, resolve ties stochastically\n# cons8 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=\"MU_FREQ\", regionDefinition=NULL,\n#                              method=\"mostMutated\", \n#                              minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=TRUE, breakTiesByColumns=NULL)\n# # mostMutated method, resolve ties deterministically using additional columns\n# cons9 <- calcClonalConsensus(db=clone,\n#                              muFreqColumn=\"MU_FREQ\", regionDefinition=NULL,\n#                              method=\"mostMutated\", \n#                              minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                              breakTiesStochastic=FALSE, \n#                              breakTiesByColumns=list(c(\"JUNCTION_LENGTH\", \"DUPCOUNT\"), c(max, max)))\n# cons10 <- calcClonalConsensus(db=clone,\n#                               muFreqColumn=\"MU_FREQ\", regionDefinition=NULL,\n#                               method=\"mostMutated\", \n#                               minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                               breakTiesStochastic=FALSE, \n#                               breakTiesByColumns=list(c(\"DUPCOUNT\"), c(max)))\n# # mostMutated method, resolve ties deterministically without using additional columns\n# cons11 <- calcClonalConsensus(db=clone,\n#                               muFreqColumn=\"MU_FREQ\", regionDefinition=NULL,\n#                               method=\"mostMutated\", \n#                               minimumFrequency=NULL, includeAmbiguous=FALSE,\n#                               breakTiesStochastic=FALSE, breakTiesByColumns=NULL)\n# @export\ncalcClonalConsensus <- function(db, \n                                sequenceColumn=\"SEQUENCE_IMGT\", \n                                germlineColumn=\"GERMLINE_IMGT_D_MASK\", \n                                muFreqColumn=NULL,\n                                regionDefinition=NULL, \n                                method=c(\"mostCommon\", \"thresholdedFreq\", \"catchAll\", \"mostMutated\", \"leastMutated\"), \n                                minimumFrequency=NULL, includeAmbiguous=FALSE,\n                                breakTiesStochastic=FALSE, breakTiesByColumns=NULL) {\n    method = match.arg(method)\n    \n    inputSeq = db[[sequenceColumn]]\n    germlineSeq = db[[germlineColumn]]\n    \n    # length of seqs in inputSeq and those in germlineSeq should match\n    if ( sum(nchar(inputSeq)==nchar(germlineSeq)) != length(inputSeq) ) {\n        stop(\"Sequences in inputSeq and germlineSeq have different lengths.\")\n    }\n    \n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # length limit from regionDefinition\n    if (!is.null(regionDefinition)) {\n        lenRegion = regionDefinition@seqLength\n    } else {\n        lenRegion = NULL\n    }\n    \n    ##### get consensus germline sequence (most common)\n    # NULL for minFreq and muFreqColumn b/c mostCommon definitely doesn't need them\n    germCons = calcClonalConsensusHelper(seqs=germlineSeq, minFreq=NULL, lenLimit=lenRegion,\n                                         mtd=\"mostCommon\", \n                                         includeAmbiguous=includeAmbiguous,\n                                         breakTiesStochastic=breakTiesStochastic,\n                                         breakTiesByColumns=NULL,\n                                         muFreqColumn=NULL, db=NULL)$cons\n    \n    ##### get consensus observed sequence\n    inputConsMuFreq = calcClonalConsensusHelper(seqs=inputSeq, minFreq=minimumFrequency, lenLimit=lenRegion,\n                                                mtd=method, \n                                                includeAmbiguous=includeAmbiguous,\n                                                breakTiesStochastic=breakTiesStochastic,\n                                                breakTiesByColumns=breakTiesByColumns,\n                                                muFreqColumn=muFreqColumn, db=db)\n    inputCons = inputConsMuFreq$cons\n    inputMuFreq = inputConsMuFreq$muFreq\n    \n    if (method %in% c(\"mostMutated\", \"leastMutated\")) {\n        # possible to have inputCons and germCons of varying lengths\n        # germCons (mostCommon) length is \"longest possible length\" for mostCommon\n        # inputCons length is min of length of most/least mutated and lenLimit\n        # if different, trim the two to same length\n        lenInput = nchar(inputCons)\n        lenGerm = nchar(germCons)\n        if (lenInput != lenGerm) {\n            minLen = min(lenInput, lenGerm)\n            inputCons = substr(inputCons, 1, minLen)\n            germCons = substr(germCons, 1, minLen)\n        }\n    }\n    \n    # sanity check: length of germCons and inputCons should be the same\n    # all methods other than most/leastMutated should expect same lengths of inputCons & germCons\n    stopifnot( nchar(germCons)==nchar(inputCons) )\n    \n    return(list(\"inputCons\"=inputCons, \"germlineCons\"=germCons, \"inputMuFreq\"=inputMuFreq))\n}\n\n\n\n\n#### Mutation counting functions ####\n\n#' Calculate observed numbers of mutations\n#'\n#' \\code{observedMutations} calculates the observed number of mutations for each \n#' sequence in the input \\code{data.frame}.\n#'\n#' @param    db                  \\code{data.frame} containing sequence data.\n#' @param    sequenceColumn      \\code{character} name of the column containing input \n#'                               sequences. IUPAC ambiguous characters for DNA are \n#'                               supported.\n#' @param    germlineColumn      \\code{character} name of the column containing \n#'                               the germline or reference sequence. Germline should \n#'                               \\strong{not} contain ambiguous characters.\n#' @param    regionDefinition    \\link{RegionDefinition} object defining the regions\n#'                               and boundaries of the Ig sequences. If NULL, mutations \n#'                               are counted for entire sequence.\n#' @param    mutationDefinition  \\link{MutationDefinition} object defining replacement\n#'                               and silent mutation criteria. If \\code{NULL} then \n#'                               replacement and silent are determined by exact \n#'                               amino acid identity.\n#' @param    frequency           \\code{logical} indicating whether or not to calculate\n#'                               mutation frequencies. Default is \\code{FALSE}.\n#' @param    combine             \\code{logical} indicating whether for each sequence should\n#'                               the mutation counts for the different regions (CDR, FWR) and \n#'                               mutation types be combined and return one value of \n#'                               count/frequency per sequence instead of \n#'                               multiple values. Default is \\code{FALSE}.                          \n#' @param    nproc               number of cores to distribute the operation over. If the \n#'                               cluster has already been set the call function with \n#'                               \\code{nproc} = 0 to not reset or reinitialize. Default is \n#'                               \\code{nproc} = 1.\n#' \n#' @return   A modified \\code{db} \\code{data.frame} with observed mutation counts for each \n#'           sequence listed. The columns names are dynamically created based on the\n#'           regions in the \\code{regionDefinition}. For example, when using the\n#'           \\link{IMGT_V} definition, which defines positions for CDR and\n#'           FWR, the following columns are added:\n#'           \\itemize{\n#'             \\item  \\code{MU_COUNT_CDR_R}:  number of replacement mutations in CDR1 and \n#'                                            CDR2 of the V-segment.\n#'             \\item  \\code{MU_COUNT_CDR_S}:  number of silent mutations in CDR1 and CDR2 \n#'                                            of the V-segment.\n#'             \\item  \\code{MU_COUNT_FWR_R}:  number of replacement mutations in FWR1, \n#'                                            FWR2 and FWR3 of the V-segment.\n#'             \\item  \\code{MU_COUNT_FWR_S}:  number of silent mutations in FWR1, FWR2 and\n#'                                            FWR3 of the V-segment.\n#'           }\n#'           If \\code{frequency=TRUE}, R and S mutation frequencies are\n#'           calculated over the number of non-N positions in the speficied regions.\n#'           \\itemize{\n#'             \\item  \\code{MU_FREQ_CDR_R}:  frequency of replacement mutations in CDR1 and \n#'                                            CDR2 of the V-segment.\n#'             \\item  \\code{MU_FREQ_CDR_S}:  frequency of silent mutations in CDR1 and CDR2 \n#'                                            of the V-segment.\n#'             \\item  \\code{MU_FREQ_FWR_R}:  frequency of replacement mutations in FWR1, \n#'                                            FWR2 and FWR3 of the V-segment.\n#'             \\item  \\code{MU_FREQ_FWR_S}:  frequency of silent mutations in FWR1, FWR2 and\n#'                                            FWR3 of the V-segment.\n#'           } \n#'           If \\code{frequency=TRUE} and \\code{combine=TRUE}, the mutations and non-N positions\n#'           are aggregated and a single \\code{MU_FREQ} value is returned\n#'           \\itemize{\n#'             \\item  \\code{MU_FREQ}:  frequency of replacement and silent mutations in the \n#'                                      specified region\n#'           }     \n#'                                  \n#' @details\n#' Mutation counts are determined by comparing the input sequences (in the column specified \n#' by \\code{sequenceColumn}) to the germline sequence (in the column specified by \n#' \\code{germlineColumn}). See \\link{calcObservedMutations} for more technical details.\n#' \n#' The mutations are binned as either replacement (R) or silent (S) across the different \n#' regions of the sequences as defined by \\code{regionDefinition}. Typically, this would \n#' be the framework (FWR) and complementarity determining (CDR) regions of IMGT-gapped \n#' nucleotide sequences. Mutation counts are appended to the input \\code{db} as \n#' additional columns.\n#' \n#' \n#' @seealso  \n#' \\link{calcObservedMutations} is called by this function to get the number of mutations \n#' in each sequence grouped by the \\link{RegionDefinition}. \n#' See \\link{IMGT_SCHEMES} for a set of predefined \\link{RegionDefinition} objects.\n#' See \\link{expectedMutations} for calculating expected mutation frequencies.\n#'           \n#' \n#' @examples\n#' # Subset example data\n#' data(ExampleDb, package=\"alakazam\")\n#' db <- subset(ExampleDb, ISOTYPE == \"IgG\" & SAMPLE == \"+7d\")\n#'\n#' # Calculate mutation frequency over the entire sequence\n#' db_obs <- observedMutations(db, sequenceColumn=\"SEQUENCE_IMGT\",\n#'                             germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n#'                             frequency=TRUE,\n#'                             nproc=1)\n#'\n#' # Count of V-region mutations split by FWR and CDR\n#' # With mutations only considered replacement if charge changes\n#' db_obs <- observedMutations(db, sequenceColumn=\"SEQUENCE_IMGT\",\n#'                             germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n#'                             regionDefinition=IMGT_V,\n#'                             mutationDefinition=CHARGE_MUTATIONS,\n#'                             nproc=1)\n#'                      \n#' @export\nobservedMutations <- function(db, \n                              sequenceColumn=\"SEQUENCE_IMGT\",\n                              germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n                              regionDefinition=NULL,\n                              mutationDefinition=NULL,\n                              frequency=FALSE,\n                              combine=FALSE,\n                              nproc=1) {\n    # Hack for visibility of foreach index variable\n    idx <- NULL\n    \n    # Check for valid columns\n    check <- checkColumns(db, c(sequenceColumn, germlineColumn))\n    if (check != TRUE) { stop(check) }\n    \n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Check if mutation count/freq columns already exist\n    # and throw overwritting warning\n    if (!is.null(regionDefinition)) {\n        labels <- regionDefinition@labels\n    } else {\n        labels <- makeNullRegionDefinition()@labels\n    }\n    if (frequency == TRUE) {\n        if (combine) {\n            labels <- \"MU_FREQ\"\n        } else {\n            labels <- paste(\"MU_FREQ_\", labels, sep=\"\")\n        }\n    } else {\n        if (combine) {\n            labels <- \"MU_COUNT\"\n        } else {\n            labels <- paste(\"MU_COUNT_\", labels, sep=\"\")\n        }\n    }\n    \n    label_exists <- labels[labels %in% colnames(db)]\n    if (length(label_exists)>0) {\n        warning(paste0(\"Columns \", \n                       paste(label_exists, collapse=\", \"),\n                       \" exist and will be overwritten\")\n        )\n        db[,label_exists] <- NULL\n    }\n    \n    \n    # Check mutation definition\n    if (!is.null(mutationDefinition) & !is(mutationDefinition, \"MutationDefinition\")) {\n        stop(deparse(substitute(mutationDefinition)), \" is not a valid MutationDefinition object\")\n    }\n    \n    # Convert sequence columns to uppercase\n    db <- toupperColumns(db, c(sequenceColumn, germlineColumn))\n    \n    # If the user has previously set the cluster and does not wish to reset it\n    if(!is.numeric(nproc)){ \n        cluster = nproc \n        nproc = 0\n    }\n    # Ensure that the nproc does not exceed the number of cores/CPUs available\n    nproc <- min(nproc, getnproc())\n    \n    # If user wants to paralellize this function and specifies nproc > 1, then\n    # initialize and register slave R processes/clusters & \n    # export all nesseary environment variables, functions and packages.  \n    if (nproc > 1) {        \n        cluster <- parallel::makeCluster(nproc, type = \"PSOCK\")\n        parallel::clusterExport(cluster, list('db', 'sequenceColumn', 'germlineColumn', \n                                              'regionDefinition', 'frequency', 'combine',\n                                              'calcObservedMutations','s2c','c2s','NUCLEOTIDES',\n                                              'NUCLEOTIDES_AMBIGUOUS', 'IUPAC2nucs',\n                                              'makeNullRegionDefinition', 'mutationDefinition',\n                                              'getCodonPos','getContextInCodon','mutationType',\n                                              'translateCodonToAminoAcid','AMINO_ACIDS','binMutationsByRegion'), \n                                envir=environment())\n        registerDoParallel(cluster)\n    } else if (nproc == 1) {\n        # If needed to run on a single core/cpu then, regsiter DoSEQ \n        # (needed for 'foreach' in non-parallel mode)\n        registerDoSEQ()\n    }\n    \n    # Printing status to console\n    #cat(\"Calculating observed number of mutations...\\n\")\n    \n    # Identify all the mutations in the sequences\n    numbOfSeqs <- nrow(db)\n    observedMutations_list <-\n        foreach(idx=iterators::icount(numbOfSeqs)) %dopar% {\n            oM <- calcObservedMutations(db[[sequenceColumn]][idx], \n                                        db[[germlineColumn]][idx],\n                                        frequency=frequency & !combine,\n                                        regionDefinition=regionDefinition,\n                                        mutationDefinition=mutationDefinition,\n                                        returnRaw = combine)\n            if (combine) {\n                num_mutations <- 0\n                if (!all(is.na(oM$pos))) {\n                    num_mutations <- sum(oM$pos$R, oM$pos$S)\n                }\n                if (!frequency) {\n                    num_mutations\n                } else {\n                    num_nonN <- sum(oM$nonN)\n                    mu_freq <- num_mutations/num_nonN\n                    mu_freq\n                }\n            } else {\n                oM   \n            }\n        }\n    \n    # Convert list of mutations to data.frame\n    if (combine) {\n        labels_length <- 1\n    } else if (!is.null(regionDefinition)) {\n        labels_length <- length(regionDefinition@labels)\n    } else{\n        #labels_length=1\n        labels_length <- length(makeNullRegionDefinition()@labels)\n    }\n    observed_mutations <- do.call( rbind, lapply(observedMutations_list, function(x) { \n        length(x) <- labels_length \n        return(x)\n    }))\n    \n    \n    sep <- \"_\"\n    if (ncol(observed_mutations) > 1) sep <- \"_\"\n    observed_mutations[is.na(observed_mutations)] <- 0\n    if (frequency == TRUE) {\n        colnames(observed_mutations) <- gsub(\"_$\",\"\",paste(\"MU_FREQ\", colnames(observed_mutations), sep=sep))\n    } else {\n        colnames(observed_mutations) <- gsub(\"_$\",\"\",paste(\"MU_COUNT\", colnames(observed_mutations), sep=sep))\n    }\n    \n    # Properly shutting down the cluster\n    if (nproc > 1) { parallel::stopCluster(cluster) }\n    \n    # Bind the observed mutations to db\n    db_new <- cbind(db, observed_mutations)\n    return(db_new)    \n}\n\n\n#' Count the number of observed mutations in a sequence.\n#'\n#' \\code{calcObservedMutations} determines all the mutations in a given input seqeunce compared\n#' to its germline sequence.\n#'\n#' @param    inputSeq            input sequence. IUPAC ambiguous characters for DNA are supported.\n#' @param    germlineSeq         germline sequence. Germline should \\strong{not} contain ambiguous\n#'                               characters.\n#' @param    regionDefinition    \\link{RegionDefinition} object defining the regions\n#'                               and boundaries of the Ig sequences. Note, only the part of\n#'                               sequences defined in \\code{regionDefinition} are analyzed.\n#'                               If NULL, mutations are counted for entire sequence.\n#' @param    mutationDefinition  \\link{MutationDefinition} object defining replacement\n#'                               and silent mutation criteria. If \\code{NULL} then \n#'                               replacement and silent are determined by exact \n#'                               amino acid identity.\n#' @param    returnRaw           return the positions of point mutations and their corresponding\n#'                               mutation types, as opposed to counts of mutations across positions.\n#'                               Also returns the number of bases used as the denominator when \n#'                               calculating frequency. Default is \\code{FALSE}.                               \n#' @param    frequency           \\code{logical} indicating whether or not to calculate\n#'                               mutation frequencies. The denominator used is the number of bases\n#'                               that are not one of \"N\", \"-\", or \".\" in either the input or the \n#'                               germline sequences. If set, this overwrites \\code{returnRaw}. \n#'                               Default is \\code{FALSE}.\n#'                               \n#' @return   For \\code{returnRaw=FALSE}, an \\code{array} with the numbers of replacement (R) \n#'           and silent (S) mutations. \n#'           \n#'           For \\code{returnRaw=TRUE}, a list containing \n#'           \\itemize{\n#'                \\item A data frame (\\code{$pos}) whose columns (\\code{position}, \\code{R}, \\code{S}, \n#'                      and \\code{region}) indicate the nucleotide position, the number of R mutations, \n#'                      the number of S mutations, and the region in which the nucleotide position is \n#'                      in.\n#'                \\item A vector (\\code{$nonN}) indicating the number of bases in regions defined by \n#'                      \\code{regionDefinition} (excluding non-triplet overhang, if any) that are not \n#'                      one of \"N\", \"-\", or \".\" in either the observed or the germline.\n#'           }\n#'           \n#'           For \\code{frequency=TRUE}, regardless of \\code{returnRaw}, an \\code{array} with the \n#'           frequencies of replacement (R) and silent (S) mutations.\n#'           \n#' @details\n#' Each mutation is considered independently in the germline context. Note, only the part of \n#' \\code{inputSeq} defined in \\code{regionDefinition} is analyzed. For example, when using \n#' the default \\link{IMGT_V} definition, then mutations in positions beyond \n#' 312 will be ignored. Additionally, non-triplet overhang at the sequence end is ignored.\n#' \n#' Only replacement (R) and silent (S) mutations are included in the results. Excluded are: \n#' \\itemize{\n#'      \\item Stop mutations\n#'      \\item Mutations occurring in codons where one or both of the observed and the \n#'            germline involve(s) one or more of \"N\", \"-\", or \".\".\n#'            \n#'            E.g.: the case in which NNN in the germline sequence is observed as NNC in \n#'            the input sequence.\n#' }\n#' In other words, a result that is \\code{NA} or zero indicates absence of R and S mutations, \n#' not necessarily all types of mutations, such as the excluded ones mentioned above.\n#' \n#' @seealso  See \\link{observedMutations} for counting the number of observed mutations \n#' in a \\code{data.frame}.\n#' \n#' @examples\n#' # Use an entry in the example data for input and germline sequence\n#' data(ExampleDb, package=\"alakazam\")\n#' in_seq <- ExampleDb[[\"SEQUENCE_IMGT\"]][100]\n#' germ_seq <-  ExampleDb[[\"GERMLINE_IMGT_D_MASK\"]][100]\n#' \n#' # Identify all mutations in the sequence\n#' ex1_raw = calcObservedMutations(in_seq, germ_seq, returnRaw=TRUE)\n#' # Count all mutations in the sequence\n#' ex1_count = calcObservedMutations(in_seq, germ_seq, returnRaw=FALSE)\n#' ex1_freq = calcObservedMutations(in_seq, germ_seq, returnRaw=FALSE, frequency=TRUE)\n#' # Compare this with ex1_count\n#' table(ex1_raw$pos$region, ex1_raw$pos$R)[, \"1\"]\n#' table(ex1_raw$pos$region, ex1_raw$pos$S)[, \"1\"]\n#' # Compare this with ex1_freq\n#' table(ex1_raw$pos$region, ex1_raw$pos$R)[, \"1\"] / ex1_raw$nonN\n#' table(ex1_raw$pos$region, ex1_raw$pos$S)[, \"1\"] / ex1_raw$nonN\n#' \n#' # Identify only mutations the V segment minus CDR3\n#' ex2_raw = calcObservedMutations(in_seq, germ_seq, \n#'                                 regionDefinition=IMGT_V, returnRaw=TRUE)\n#' # Count only mutations the V segment minus CDR3\n#' ex2_count = calcObservedMutations(in_seq, germ_seq, \n#'                                   regionDefinition=IMGT_V, returnRaw=FALSE)\n#' ex2_freq = calcObservedMutations(in_seq, germ_seq, \n#'                                  regionDefinition=IMGT_V, returnRaw=FALSE,\n#'                                  frequency=TRUE)\n#' # Compare this with ex2_count\n#' table(ex2_raw$pos$region, ex2_raw$pos$R)[, \"1\"]\n#' table(ex2_raw$pos$region, ex2_raw$pos$S)[, \"1\"]                              \n#' # Compare this with ex2_freq\n#' table(ex2_raw$pos$region, ex2_raw$pos$R)[, \"1\"] / ex2_raw$nonN     \n#' table(ex2_raw$pos$region, ex2_raw$pos$S)[, \"1\"] / ex2_raw$nonN                                       \n#' \n#' # Identify mutations by change in hydropathy class\n#' ex3_raw = calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,\n#'                                 mutationDefinition=HYDROPATHY_MUTATIONS, returnRaw=TRUE)\n#' # Count mutations by change in hydropathy class\n#' ex3_count = calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,\n#'                                   mutationDefinition=HYDROPATHY_MUTATIONS, returnRaw=FALSE)\n#' ex3_freq = calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,\n#'                                  mutationDefinition=HYDROPATHY_MUTATIONS, returnRaw=FALSE, \n#'                                  frequency=TRUE)\n#' # Compre this with ex3_count\n#' table(ex3_raw$pos$region, ex3_raw$pos$R)[, \"1\"]\n#' table(ex3_raw$pos$region, ex3_raw$pos$S)[, \"1\"]\n#' # Compare this with ex3_freq\n#' table(ex3_raw$pos$region, ex3_raw$pos$R)[, \"1\"] / ex3_raw$nonN                                        \n#' table(ex3_raw$pos$region, ex3_raw$pos$S)[, \"1\"] / ex3_raw$nonN                                        \n#'                                 \n#' @export\ncalcObservedMutations <- function(inputSeq, germlineSeq,\n                                  regionDefinition=NULL, mutationDefinition=NULL,\n                                  returnRaw=FALSE, frequency=FALSE) {\n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Check mutation definition\n    if (!is.null(mutationDefinition) & !is(mutationDefinition, \"MutationDefinition\")) {\n        stop(deparse(substitute(mutationDefinition)), \" is not a valid MutationDefinition object\")\n    }\n    \n    # IMPORTANT: convert to uppercase \n    # NUCLEOTIDES, NUCLEOTIDES_AMBIGUOUS are in uppercases only\n    inputSeq = toupper(inputSeq)\n    germlineSeq = toupper(germlineSeq)\n    \n    # check germlineSeq does not have ambiguous character (except for N)\n    if (any(s2c(germlineSeq) %in% NUCLEOTIDES_AMBIGUOUS[5:14])) {\n        stop(\"germlineSeq cannot contain ambiguous characters.\")\n    }\n    \n    # Assign mutation definition\n    aminoAcidClasses <- if (is.null(mutationDefinition)) { NULL } else { mutationDefinition@classes }\n    \n    # Removing IMGT gaps (they should come in threes)\n    # After converting ... to XXX any other . is not an IMGT gap & will be treated like N\n    germlineSeq <- gsub(\"\\\\.\\\\.\\\\.\", \"XXX\", germlineSeq)\n    #If there is a single gap left convert it to an N\n    germlineSeq <- gsub(\"\\\\.\", \"N\", germlineSeq)\n    # Re-assigning s_germlineSeq (now has all \".\" that are not IMGT gaps converted to Ns)\n    germlineSeq <- gsub(\"XXX\", \"...\", germlineSeq)\n    \n    # Removing IMGT gaps (they should come in threes)\n    # After converting ... to XXX any other . is not an IMGT gap & will be treated like N\n    inputSeq <- gsub(\"\\\\.\\\\.\\\\.\", \"XXX\", inputSeq)\n    #If there is a single gap left convert it to an N\n    inputSeq <- gsub(\"\\\\.\", \"N\", inputSeq)\n    # Re-assigning s_germlineSeq (now has all \".\" that are not IMGT gaps converted to Ns)\n    inputSeq <- gsub(\"XXX\", \"...\", inputSeq)    \n    \n    # Trim the input and germline sequence to the shortest\n    len_inputSeq <- nchar(inputSeq)\n    len_germlineSeq <- nchar(germlineSeq)\n    \n    # If a regionDefinition is passed,\n    # then only analyze till the end of the defined length\n    if(!is.null(regionDefinition)) {\n        rdLength  <- regionDefinition@seqLength\n    } else {\n        rdLength <- max(len_inputSeq, len_germlineSeq, na.rm=TRUE)\n        # Create full sequence RegionDefinition object\n        regionDefinition <- makeNullRegionDefinition(rdLength)\n    }\n    len_shortest <- min(c(len_inputSeq, len_germlineSeq, rdLength), na.rm=TRUE)\n    \n    c_inputSeq <- s2c(inputSeq)[1:len_shortest]\n    c_germlineSeq <- s2c(germlineSeq)[1:len_shortest]\n    \n    # If the sequence and germline (which now should be the same length) is shorter\n    # than the rdLength, pad it with Ns\n    if(len_shortest<rdLength){\n        fillWithNs <- array(\"N\",rdLength-len_shortest)\n        c_inputSeq <- c( c_inputSeq, fillWithNs)\n        c_germlineSeq <- c( c_germlineSeq, fillWithNs)\n    }\n    \n    # length of c_inputSeq and c_germlineSeq should be multiples of 3; if not, trim\n    # at this point, c_inputSeq and c_germlineSeq have the same length\n    # this is NECESSARY because otherwise the example below could happen:\n    # inputSeq 400..402 (codon 134) is \"G  \" (no info at 401 and 402);\n    # c_inputSeq_codons 400..402 will end up being \"G\" NA NA,\n    # which will be turned by the code strsplit(gsub... into\n    # \"GNA\" \"NA\" (2 codons!)\n    stopifnot(length(c_inputSeq)==length(c_germlineSeq))\n    seqLen = length(c_inputSeq)\n    # return NA if seqLen shorter than one complete codon\n    # consistent with policy that non-triplet overhang is ignored\n    if (seqLen<3) {\n        tooShort = TRUE\n    } else {\n        tooShort = FALSE\n        # if there's non-triplet overhang, trim/ignore\n        if ( (seqLen%%3)!=0 ) {\n            c_inputSeq = c_inputSeq[ 1:(seqLen-(seqLen%%3)) ]\n            c_germlineSeq = c_germlineSeq[ 1:(seqLen-(seqLen%%3)) ]\n        }\n        stopifnot( (length(c_inputSeq)%%3)==0 )\n        stopifnot( (length(c_germlineSeq)%%3)==0 )\n    }\n    \n    mutations_array_raw <- NA\n    mutations_array <- setNames(object=rep(NA, length(regionDefinition@labels)), \n                                nm=regionDefinition@labels)\n    \n    if (!tooShort) {\n        # locate mutations\n        # germline is one of ATGCN \n        # input is one of ATGCN and IUPAC ambiguous characters\n        # character mismatch between germline & input (captures both cases like A vs. T, and W vs. T)\n        mutations = ( (c_germlineSeq != c_inputSeq) & \n                          (c_germlineSeq %in% NUCLEOTIDES[1:5]) & \n                          (c_inputSeq %in% NUCLEOTIDES_AMBIGUOUS[1:15]) ) \n        #print(sum(mutations))\n        if (sum(mutations) > 0) {\n            # The nucleotide positions of the mutations\n            mutations_pos <- which(mutations==TRUE)\n            # For every mutations_pos, extract the entire codon from germline\n            mutations_pos_codons <- array(sapply(mutations_pos, getCodonPos))\n            c_germlineSeq_codons <- c_germlineSeq[mutations_pos_codons]\n            # For every mutations_pos, extract the codon from input (without other mutations \n            # at the same codon, if any).\n            c_inputSeq_codons <- array(sapply(mutations_pos, function(x) {\n                seqP = c_germlineSeq[getCodonPos(x)]\n                seqP[getContextInCodon(x)] = c_inputSeq[x]\n                return(seqP) }))\n            # split the string of codons into vector of codons\n            c_germlineSeq_codons <- strsplit(gsub(\"([[:alnum:]]{3})\", \"\\\\1 \", c2s(c_germlineSeq_codons)), \" \")[[1]]\n            c_inputSeq_codons <- strsplit(gsub(\"([[:alnum:]]{3})\", \"\\\\1 \", c2s(c_inputSeq_codons)), \" \")[[1]]\n            \n            # Determine whether the mutations are R or S\n            # a table where rows are R/S/Stop/na, cols are codon positions\n            mutations_array_raw <- apply(rbind(c_germlineSeq_codons, c_inputSeq_codons), 2, \n                                         function(x) { mutationType(x[1], x[2], aminoAcidClasses=aminoAcidClasses) })\n            # check dimension before assigning nucleotide positions to colnames\n            stopifnot(ncol(mutations_array_raw)==length(mutations_pos))\n            colnames(mutations_array_raw) = mutations_pos\n            \n            # keep only columns in which there are R or S mutations; and keep only R and S rows\n            # use drop=FALSE so that matrix won't be collapsed into a vector if there is only 1 TRUE in keep.idx\n            keep.idx = apply(mutations_array_raw, 2, function(x) { any(x[c(\"R\", \"S\")]>0) } )\n            keep.pos = colnames(mutations_array_raw)[keep.idx]\n            mutations_array_raw = mutations_array_raw[c(\"R\", \"S\"), keep.idx, drop=FALSE]\n            colnames(mutations_array_raw) = keep.pos\n            \n            # if none of columns have R or S > 1, dim will be 2x0\n            if ( ncol(mutations_array_raw)==0 ) {\n                # NA if mutations_array_raw contains all NAs and they have all been removed\n                mutations_array_raw <- NA\n                mutations_array <- setNames(object=rep(NA, length(regionDefinition@labels)), \n                                            nm=regionDefinition@labels)\n            } else {\n                # count each mutation type by region\n                mutations_array <- binMutationsByRegion(mutations_array_raw, regionDefinition)\n            }\n        }\n    }\n    \n    # frequency=TRUE overrides returnRaw=FALSE/TRUE\n    if (frequency) {\n        # avoid is.na(mutations_array_raw) to avoid warning in case mutations_array_raw is a vector\n        if (length(mutations_array_raw) == sum(is.na(mutations_array_raw))) {\n            return(mutations_array)\n        } else {\n            tempNames <- sapply(regionDefinition@labels, function(x) { substr(x, 1, nchar(x)-2) })\n            # Subset boundaries to only non-N & non-dash & non-dot bases (in both seq and gl)\n            # \"which\" in next line is ESSENTIAL; otherwise @boundaries won't be truncated\n            # e.g. (1:6)[c(T,T,T)] returns 1:6, not 1:3\n            boundaries <- regionDefinition@boundaries[which(c_inputSeq %in% NUCLEOTIDES_AMBIGUOUS[1:14] &  \n                                                            c_germlineSeq%in%NUCLEOTIDES[1:4])]\n            # Freq = numb of mutations / numb of non N bases (in both seq and gl)\n            denoms <- sapply(tempNames, function(x) { sum(boundaries==x) })\n            mutations_array <- mutations_array/denoms\n            return(mutations_array)\n        }\n    }\n    \n    # return positions of point mutations and their mutation types (\"raw\")\n    if (returnRaw){\n        # number of non-N, non-dash, non-dot bases (in both seq and gl)\n        nonN.regions <- unique(sapply(regionDefinition@labels, function(x) { substr(x, 1, nchar(x)-2) }))\n        \n        if (!tooShort) {\n            # \"which\" in next line is ESSENTIAL; otherwise @boundaries won't be truncated\n            # e.g. (1:6)[c(T,T,T)] returns 1:6, not 1:3\n            nonN.boundaries <- regionDefinition@boundaries[which(c_inputSeq %in% NUCLEOTIDES_AMBIGUOUS[1:14] &  \n                                                                     c_germlineSeq %in% NUCLEOTIDES[1:4])]\n            nonN.denoms <- sapply(nonN.regions, function(x) { sum(nonN.boundaries==x) })\n        } else {\n            nonN.denoms = setNames(object=rep(NA, length(nonN.regions)), nm=nonN.regions)\n        }\n        \n        if (length(mutations_array_raw) == sum(is.na(mutations_array_raw))) {\n            # if mutations_array_raw is NA, or \n            # if mutations_array_raw is empty due to all mutations being \"Stop\" and hence removed\n            # avoid is.na(mutations_array_raw) to avoid warning in case mutations_array_raw is a vector\n            return(list(pos=mutations_array_raw, nonN=nonN.denoms))\n        } else {\n            # df indicating position, mutation type (R or S), and region of each mutation\n            rawDf = data.frame(as.numeric(colnames(mutations_array_raw)))\n            rawDf = cbind(rawDf,\n                          mutations_array_raw[\"R\", ],\n                          mutations_array_raw[\"S\", ],\n                          as.character(regionDefinition@boundaries[as.numeric(colnames(mutations_array_raw))]),\n                          stringsAsFactors=F)\n            colnames(rawDf) = c(\"position\", \"R\", \"S\", \"region\")\n            return(list(pos=rawDf, nonN=nonN.denoms))\n        }\n    } else {\n        # return counts of each mutation type  \n        return(mutations_array)\n    }\n}\n\n\n# Aggregate mutations by region\n#\n# \\code{binMutationsByRegion} takes an array of observed mutations (e.g. from \n# \\code{calcObservedMutations}) and bins them by the different regions defined in the \n# \\code{regionDefinition}.\n#\n# @param   mutationsArray     \\code{array} containing the number of R and S mutations \n#                             at the nucleotide positions where there are mutations.                             \n# @param   regionDefinition   \\link{RegionDefinition} object defining the regions\n#                             and boundaries of the Ig sequences.\n# \n# @return An \\code{array} of R/S mutations binned across all the unique regions defined\n# by \\code{regionDefinition}.\n# \n# @details\n# Note, only the part of sequences defined in \\code{regionDefinition} are analyzed.\n# For example, if the default \\link{IMGT_V} definition is used, then mutations\n# in positions beyond 312 will be ignored.\n# \n# @seealso  \n# See \\link{observedMutations} for identifying and counting the \n# number of observed mutations.\n# This function is also used in \\link{calcObservedMutations}.\n# \n# @examples\n# # Generate a random mutation array\n# numbOfMutPos <- sample(3:10, 1)\n# posOfMutations <- sort(sample(330, numbOfMutPos))\n# mutations_array <- matrix(0, nrow=2, ncol=numbOfMutPos, dimnames=list(c(\"R\", \"S\"), posOfMutations))\n# mutations_array[\"R\", ] = sample(x=0:10, size=numbOfMutPos, replace=TRUE)\n# mutations_array[\"S\", ] = sample(x=0:10, size=numbOfMutPos, replace=TRUE)\n\n# # Random mutations\n# binMutationsByRegion(mutations_array, regionDefinition=NULL)\n# binMutationsByRegion(mutations_array, regionDefinition=IMGT_V)\nbinMutationsByRegion <- function(mutationsArray, \n                                 regionDefinition=NULL) {\n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Create full sequence RegionDefinition object \n    # The seqLength will be the largest index of a mutation\n    if (is.null(regionDefinition)) {\n        regionDefinition <- makeNullRegionDefinition(max(as.numeric(colnames(mutationsArray))))\n    }\n    \n    # get 2 vectors, 1 for R, 1 for S, along length of 1:regionDefinition@seqLength\n    # each vector records the number of R/S at each position\n    mutatedPositions <- as.numeric(colnames(mutationsArray)) \n    \n    mutations_R <- array(NA,  dim=regionDefinition@seqLength)\n    mutations_S <- array(NA,  dim=regionDefinition@seqLength)\n    mutations_R[mutatedPositions] <- mutationsArray[\"R\", ]\n    mutations_S[mutatedPositions] <- mutationsArray[\"S\", ]\n    mutations_R <- mutations_R[1:regionDefinition@seqLength]\n    mutations_S <- mutations_S[1:regionDefinition@seqLength]\n    \n    # count number of R/S in each region\n    mutations_region_counts = rep(0, length(regionDefinition@labels))\n    names(mutations_region_counts) = regionDefinition@labels\n    for (reg in regionDefinition@regions) {\n        mutations_region_counts[paste0(reg, \"_R\")] = sum(mutations_R[regionDefinition@boundaries==reg], na.rm=T)\n        mutations_region_counts[paste0(reg, \"_S\")] = sum(mutations_S[regionDefinition@boundaries==reg], na.rm=T)\n    }\n    \n    return(mutations_region_counts)\n}\n\n\n\n#### Sliding window approach ####\n#' Sliding window approach towards filtering a single sequence\n#'\n#' \\code{slideWindowSeq} determines whether an input sequence contains equal to or more than \n#' a given number of mutations in a given length of consecutive nucleotides (a \"window\") \n#' when compared to a germline sequence.\n#' \n#' @param    inputSeq            input sequence.\n#' @param    germlineSeq         germline sequence.\n#' @param    mutThresh           threshold on the number of mutations in \\code{windowSize} \n#'                               consecutive nucleotides. Must be between 1 and \\code{windowSize} \n#'                               inclusive. \n#' @param    windowSize          length of consecutive nucleotides. Must be at least 2.\n#'                               \n#' @return  \\code{TRUE} if there are equal to or more than \\code{mutThresh} number of mutations\n#'          in any window of \\code{windowSize} consecutive nucleotides (i.e. the sequence should\n#'          be filtered); \\code{FALSE} if otherwise.\n#' \n#' @seealso  \\link{calcObservedMutations} is called by \\code{slideWindowSeq} to identify observed \n#'           mutations. See \\link{slideWindowDb} for applying the sliding window approach on a \n#'           \\code{data.frame}. See \\link{slideWindowTune} for parameter tuning for \\code{mutThresh}\n#'           and \\code{windowSize}.\n#' \n#' @examples\n#' # Use an entry in the example data for input and germline sequence\n#' data(ExampleDb, package=\"alakazam\")\n#' in_seq <- ExampleDb[100, \"SEQUENCE_IMGT\"]\n#' germ_seq <-  ExampleDb[100, \"GERMLINE_IMGT_D_MASK\"]\n#' \n#' # Determine if in_seq has 6 or more mutations in 10 consecutive nucleotides\n#' slideWindowSeq(inputSeq=in_seq, germlineSeq=germ_seq, mutThresh=6, windowSize=10)\n#'                                 \n#' @export\nslideWindowSeq <- function(inputSeq, germlineSeq, mutThresh, windowSize){\n    # identify all R and S mutations in input sequence\n    inputMut <- calcObservedMutations(inputSeq=inputSeq, germlineSeq=germlineSeq, returnRaw=T)\n    \n    # call helper\n    return(slideWindowSeqHelper(mutPos=inputMut$pos, mutThresh=mutThresh, windowSize=windowSize))\n}\n\n\n# NOTE: DO NOT MERGE slideWindowSeqHelper with slideWindowSeq (very different input formats)\n#       slideWindowTune needs to call slideWindowSeqHelper directly for efficiency\n# Helper for sliding window approach towards filtering sequences\n#\n# @param    mutPos              a \\code{data.frame} containing positions and types of point \n#                               mutations as returned in \\code{$pos} by \n#                               \\code{calcObserverdMutations()} with \\code{returnRaw=TRUE}. \n#                               Can be \\code{NA}, in which case the returned value will be \n#                               \\code{FALSE}.\n# @param    mutThresh           threshold on the number of mutations in \\code{windowSize} \n#                               consecutive nucleotides. Must be between 1 and \\code{windowSize} \n#                               inclusive.\n# @param    windowSize          length of consecutive nucleotides. Must be at least 2.\n#\n# @return   \\code{TRUE} if there are equal to or more than \\code{mutThresh} number of mutations\n#           in any window of \\code{windowSize} consecutive nucleotides; \\code{FALSE} if otherwise.\n#\nslideWindowSeqHelper <- function(mutPos, mutThresh, windowSize){\n    # check preconditions\n    stopifnot(mutThresh >= 1 & mutThresh <= windowSize & windowSize>=2)\n    \n    if (length(mutPos) == 1 && is.na(mutPos)) {\n        # use && instead of & to short-circuit in case length(mutPos)!=1 (otherwise warning)\n        return(FALSE)\n    } else {\n        # general idea:\n        # only need to check windows containing mutations (as opposed to every possible window)\n        for (i in 1:nrow(mutPos)){\n            # get window limits\n            lower = mutPos$position[i]\n            upper = lower + windowSize - 1\n            # how many mutations fall within current window\n            windowCount = sum(mutPos[mutPos$position>=lower & mutPos$position<=upper, c(\"R\",\"S\")])\n            # return as soon as a window has >= mutThresh mutations\n            if (windowCount >= mutThresh) { return(TRUE) }\n        }\n        \n        return(FALSE)\n    }\n}\n\n\n#' Sliding window approach towards filtering sequences in a \\code{data.frame}\n#'\n#' \\code{slideWindowDb} determines whether each input sequence in a \\code{data.frame} \n#' contains equal to or more than a given number of mutations in a given length of \n#' consecutive nucleotides (a \"window\") when compared to their respective germline \n#' sequence.\n#' \n#' @param    db                  \\code{data.frame} containing sequence data.\n#' @param    sequenceColumn      name of the column containing IMGT-gapped sample sequences.\n#' @param    germlineColumn      name of the column containing IMGT-gapped germline sequences.\n#' @param    mutThresh           threshold on the number of mutations in \\code{windowSize} \n#'                               consecutive nucleotides. Must be between 1 and \\code{windowSize} \n#'                               inclusive. \n#' @param    windowSize          length of consecutive nucleotides. Must be at least 2.\n#'                               \n#' @return   a logical vector. The length of the vector matches the number of input sequences in \n#'           \\code{db}. Each entry in the vector indicates whether the corresponding input sequence\n#'           should be filtered based on the given parameters.\n#' \n#' @seealso  See \\link{slideWindowSeq} for applying the sliding window approach on a single sequence. \n#'           See \\link{slideWindowTune} for parameter tuning for \\code{mutThresh} and \\code{windowSize}.\n#' \n#' @examples\n#' # Use an entry in the example data for input and germline sequence\n#' data(ExampleDb, package=\"alakazam\")\n#' \n#' # Apply the sliding window approach on a subset of ExampleDb\n#' slideWindowDb(db = ExampleDb[1:10, ], mutThresh=6, windowSize=10)\n#' \n#' @export\nslideWindowDb <- function(db, sequenceColumn=\"SEQUENCE_IMGT\", \n                          germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n                          mutThresh, windowSize){\n    db_filter <- sapply(1:nrow(db), function(i) { slideWindowSeq(inputSeq = db[i, sequenceColumn],\n                                                                 germlineSeq = db[i, germlineColumn],\n                                                                 mutThresh = mutThresh,\n                                                                 windowSize = windowSize)})\n    return(db_filter)\n}\n\n\n#' Parameter tuning for sliding window approach\n#'\n#' Apply \\link{slideWindowDb} over a search grid made of combinations of \\code{mutThresh} and \n#' \\code{windowSize} to help with picking a pair of values for these parameters. Parameter \n#' tuning can be performed by choosing a combination that gives a reasonable number of \n#' filtered/remaining sequences. \n#' \n#' @param    db                  \\code{data.frame} containing sequence data.\n#' @param    sequenceColumn      name of the column containing IMGT-gapped sample sequences.\n#' @param    germlineColumn      name of the column containing IMGT-gapped germline sequences.\n#' @param    dbMutList           if supplied, this should be a list consisting of \\code{data.frame}s \n#'                               returned as \\code{$pos} in the nested list produced by \n#'                               \\link{calcObservedMutations} with \\code{returnRaw=TRUE}; otherwise, \n#'                               \\link{calcObservedMutations} is called on columns \\code{sequenceColumn}\n#'                               and \\code{germlineColumn} of \\code{db}. Default is \\code{NULL}. \n#' @param    mutThreshRange      range of threshold on the number of mutations in \\code{windowSize} \n#'                               consecutive nucleotides to try. Must be between 1 and \n#'                               maximum \\code{windowSizeRange} inclusive. \n#' @param    windowSizeRange     range of length of consecutive nucleotides to try. The lower end\n#'                               must be at least 2.\n#' @param    verbose             whether to print out messages indicating current progress. Default\n#'                               is \\code{TRUE}.              \n#'                               \n#' @return   a list of logical matrices. Each matrix corresponds to a \\code{windowSize} in \n#'           \\code{windowSizeRange}. Each column in a matrix corresponds to a \\code{mutThresh} in\n#'           \\code{mutThreshRange}.\n#' \n#' @details  If, in a given combination of \\code{mutThresh} and \\code{windowSize}, \\code{mutThresh} \n#'           is greater than \\code{windowSize}, \\code{NA}s will be returned for that particular\n#'           combination. A message indicating that the combination has been \"skipped\" will be \n#'           printed if \\code{verbose=TRUE}.\n#'           \n#'           If \\link{calcObservedMutations} was previously run on \\code{db} and saved, supplying\n#'           \\code{$pos} from the saved result as \\code{dbMutList} could save time by skipping a\n#'           second call of \\link{calcObservedMutations}. This could be helpful especially when \n#'           \\code{db} is large.\n#' \n#' @seealso  \\link{slideWindowDb} is called on \\code{db} for tuning. See \\link{slideWindowTunePlot} \n#'           for visualization. See \\link{calcObservedMutations} for generating \\code{dbMutList}.\n#' \n#' @examples\n#' # Load and subset example data\n#' data(ExampleDb, package=\"alakazam\")\n#' db <- ExampleDb[1:5, ]\n#' \n#' # Try out thresholds of 2-4 mutations in window sizes of 7-9 nucleotides. \n#' # In this case, all combinations are legal.\n#' slideWindowTune(db, mutThreshRange=2:4, windowSizeRange=7:9)\n#' \n#' # Illegal combinations are skipped, returning NAs.\n#' slideWindowTune(db, mutThreshRange=2:4, windowSizeRange=2:4, \n#'                 verbose=FALSE)\n#'                                                             \n#' # Run calcObservedMutations separately\n#' exDbMutList <- sapply(1:5, function(i) {\n#'     calcObservedMutations(inputSeq=db[i, \"SEQUENCE_IMGT\"],\n#'                           germlineSeq=db[i, \"GERMLINE_IMGT_D_MASK\"],\n#'                           returnRaw=TRUE)$pos })\n#' slideWindowTune(db, dbMutList=exDbMutList, \n#'                 mutThreshRange=2:4, windowSizeRange=2:4)\n#'                                                            \n#' @export\nslideWindowTune <- function(db, sequenceColumn=\"SEQUENCE_IMGT\", \n                            germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n                            dbMutList=NULL,\n                            mutThreshRange, windowSizeRange, verbose=TRUE){\n    # check preconditions\n    stopifnot(!is.null(db))\n    stopifnot(min(mutThreshRange) >= 1 & \n                  max(mutThreshRange) <= max(windowSizeRange) &\n                  min(windowSizeRange) >= 2)\n    \n    \n    # get positions of R/S mutations for sequences in db\n    # do this here and then call slideWindowSeqHelper (so it's done only once)\n    # instead of calling slideWindowDb which does this every time it is called\n    if (is.null(dbMutList)) {\n        inputMutList = sapply(1:nrow(db), \n                              function(i){\n                                  calcObservedMutations(inputSeq=db[i, sequenceColumn],\n                                                        germlineSeq=db[i, germlineColumn],\n                                                        returnRaw=T)$pos})    \n    } else {\n        if (verbose) {cat(\"dbMutList supplied; skipped calling calcObservedMutations()\\n\")}\n        inputMutList = dbMutList\n    }\n    \n    # apply slideWindow on combinations of windowSize and mutThresh\n    for (size in windowSizeRange) {\n        if (verbose) {cat(paste0(\"now computing for windowSize = \", size, \"\\n\"))}\n        \n        for (thresh in mutThreshRange) {\n            if (thresh <= size){\n                if (verbose) {cat(paste0(\">>> mutThresh = \", thresh, \"\\n\"))}\n                # apply slideWindow using current pair of parameters\n                cur.logical = unlist(lapply(inputMutList,\n                                            slideWindowSeqHelper,\n                                            mutThresh = thresh, windowSize = size))\n            } else {\n                if (verbose) {cat(paste0(\">>> mutThresh = \", thresh, \" > windowSize = \", \n                                         size, \" (skipped)\\n\"))}\n                # NA if skipped\n                cur.logical = rep(NA, nrow(db))\n            }\n            # store results for each thresh as a column in a logical matrix\n            if (thresh == mutThreshRange[1]) {\n                cur.mtx = matrix(data=cur.logical, nrow=length(cur.logical))\n            } else {\n                cur.mtx = cbind(cur.mtx, cur.logical)\n            }\n        }\n        colnames(cur.mtx) = as.character(mutThreshRange)\n        \n        # store results for each size (and threshes under that size) as a logical matrix in a list\n        if (size == windowSizeRange[1]) {\n            cur.list = list(cur.mtx)\n        } else {\n            cur.list = c(cur.list, list(cur.mtx))\n        }\n    }\n    names(cur.list) = as.character(windowSizeRange)\n    \n    return(cur.list)\n}\n\n\n#' Visualize parameter tuning for sliding window approach\n#'\n#' Visualize results from \\link{slideWindowTune}\n#' \n#' @param    tuneList            a list of logical matrices returned by \\link{slideWindowTune}.\n#' @param    plotFiltered        whether to plot the number of filtered sequences (as opposed to\n#'                               the number of remaining sequences). Default is \\code{TRUE}.\n#' @param    percentage          whether to plot on the y-axis the percentage of filtered sequences\n#'                               (as opposed to the absolute number). Default is \\code{FALSE}.                             \n#' @param    jitter.x            whether to jitter x-axis values. Default is \\code{FALSE}.                               \n#' @param    jitter.x.amt        amount of jittering to be applied on x-axis values if \n#'                               \\code{jitter.x=TRUE}. Default is 0.1.\n#' @param    jitter.y            whether to jitter y-axis values. Default is \\code{FALSE}.\n#' @param    jitter.y.amt        amount of jittering to be applied on y-axis values if \n#'                               \\code{jitter.y=TRUE}. Default is 0.1.                               \n#' @param    pchs                point types to pass on to \\link{plot}.\n#' @param    ltys                line types to pass on to \\link{plot}.\n#' @param    cols                colors to pass on to \\link{plot}.                             \n#' @param    plotLegend          whether to plot legend. Default is \\code{TRUE}.\n#' @param    legendPos           position of legend to pass on to \\link{legend}. Can be either a\n#'                               numeric vector specifying x-y coordinates, or one of \n#'                               \\code{\"topright\"}, \\code{\"center\"}, etc. Default is \\code{\"topright\"}.\n#' @param    legendHoriz         whether to make legend horizontal. Default is \\code{FALSE}.\n#' @param    legendCex           numeric values by which legend should be magnified relative to 1.\n#' @param    title               plot main title. Default is NULL (no title)\n#' \n#' @details  For each \\code{windowSize}, the numbers of sequences filtered or remaining after applying\n#'           the sliding window approach are plotted on the y-axis against thresholds on the number of\n#'           mutations in a window on the x-axis.\n#'           \n#'           When plotting, a user-defined \\code{amount} of jittering can be applied on values plotted\n#'           on either axis or both axes via adjusting \\code{jitter.x}, \\code{jitter.y}, \n#'           \\code{jitter.x.amt} and \\code{jitter.y.amt}. This may be help with visually distinguishing\n#'           lines for different window sizes in case they are very close or identical to each other. \n#'           If plotting percentages (\\code{percentage=TRUE}) and using jittering on the y-axis values \n#'           (\\code{jitter.y=TRUE}), it is strongly recommended that \\code{jitter.y.amt} be set very\n#'           small (e.g. 0.01). \n#'           \n#'           \\code{NA} for a combination of \\code{mutThresh} and \\code{windowSize} where \n#'           \\code{mutThresh} is greater than \\code{windowSize} will not be plotted. \n#' \n#' @seealso  See \\link{slideWindowTune} for how to get \\code{tuneList}. See \\link{jitter} for \n#'           use of \\code{amount} of jittering.\n#' \n#' @examples\n#' # Use an entry in the example data for input and germline sequence\n#' data(ExampleDb, package=\"alakazam\")\n#' \n#' # Try out thresholds of 2-4 mutations in window sizes of 3-5 nucleotides \n#' # on a subset of ExampleDb\n#' tuneList = slideWindowTune(db = ExampleDb[1:10, ], \n#'                            mutThreshRange = 2:4, windowSizeRange = 3:5,\n#'                            verbose = FALSE)\n#'\n#' # Visualize\n#' # Plot numbers of sequences filtered without jittering y-axis values\n#' slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3, \n#'                     plotFiltered=TRUE, jitter.y=FALSE)\n#'                     \n#' # Notice that some of the lines overlap\n#' # Jittering could help\n#' slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3,\n#'                     plotFiltered=TRUE, jitter.y=TRUE)\n#'                     \n#' # Plot numbers of sequences remaining instead of filtered\n#' slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3, \n#'                     plotFiltered=FALSE, jitter.y=TRUE, \n#'                     legendPos=\"bottomright\")\n#'                     \n#' # Plot percentages of sequences filtered with a tiny amount of jittering\n#' slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3,\n#'                     plotFiltered=TRUE, percentage=TRUE, \n#'                     jitter.y=TRUE, jitter.y.amt=0.01)\n#'                                                             \n#' @export\nslideWindowTunePlot = function(tuneList, plotFiltered = TRUE, percentage = FALSE,\n                               jitter.x = FALSE, jitter.x.amt = 0.1,\n                               jitter.y = FALSE, jitter.y.amt = 0.1,\n                               pchs = 1, ltys = 2, cols = 1,\n                               plotLegend = TRUE, legendPos = \"topright\", \n                               legendHoriz = FALSE, legendCex = 1, title=NULL){\n    \n    # invert (!) tuneList if plotting retained sequences\n    ylab.part.2 = \"filtered\"\n    if (!plotFiltered) {\n        tuneList = lapply(tuneList, function(x){!x})\n        ylab.part.2 = \"remaining\"}\n    \n    # if number of pchs/ltys/cols provided does not match number of lines expected\n    # expand into vector with repeating values (otherwise legend would break)\n    if (length(pchs)!=length(tuneList)) {pchs = rep(pchs, length.out=length(tuneList))}\n    if (length(ltys)!=length(tuneList)) {ltys = rep(ltys, length.out=length(tuneList))}\n    if (length(cols)!=length(tuneList)) {cols = rep(cols, length.out=length(tuneList))}\n    \n    # tabulate tuneList (and if applicable convert to percentage)\n    plotList = lapply(tuneList, colSums)\n    if (percentage) {plotList = lapply(plotList, function(x){x/nrow(tuneList[[1]])})}\n    \n    # get x-axis values (i.e. mutThreshRange; colnames of matrix in tuneList with most columns)\n    #threshes = as.numeric(colnames(tuneList[[which.max(lapply(lapply(tuneList, colnames), length))]]))\n    threshes = as.numeric(colnames(tuneList[[1]]))\n    \n    # plot for first window size\n    x1 = threshes\n    if (jitter.x) {x1 = jitter(x1, amount=jitter.x.amt)}\n    y1 = plotList[[1]]\n    if (jitter.y) {y1 = jitter(y1, amount=jitter.y.amt)}\n    \n    if (percentage) {\n        ylab.part.1 = \"Percentage of sequences\"\n        # ylim\n        ylim.padding = abs(diff(range(plotList, na.rm=T)))*0.01\n        ylims = c(max(0, min(range(plotList, na.rm=T)) - ylim.padding), \n                  min(1, max(range(plotList, na.rm=T)) + ylim.padding) )\n        \n    } else {\n        ylab.part.1 = \"Number of sequences\"\n        # ylim: non-negative lower limit; upper limit slight above max tabulated sum\n        ylims = c( max(0, min(range(plotList, na.rm=T)) - max(1, jitter.y.amt) ), \n                   max(range(plotList, na.rm=T)) + max(1, jitter.y.amt) )\n    }\n    \n    plot(x1, # mutThreshRange on x-axis\n         y1, # tabulated sums in plotList on y-axis\n         ylim = ylims,\n         # xlim: +/- jitter.x.amt*2 to accommodate for amount of jittering on x-axis\n         xlim = c(min(threshes)-jitter.x.amt*2, max(threshes+jitter.x.amt*2)),\n         xaxt=\"n\", xlab=\"Threshold on number of mutations\",\n         ylab=paste(ylab.part.1, ylab.part.2),\n         cex.lab=1.5, cex.axis=1.5, type=\"b\", lwd=1.5,\n         pch=pchs[1], lty=ltys[1], col=cols[1])\n    axis(side=1, at=threshes, cex.axis=1.5)\n    \n    # add title\n    if (!is.null(title)) {\n        title(main=title)\n    }\n    \n    # plot for the rest of the window sizes\n    for (i in 1:length(plotList)){\n        if (i>=2) {\n            \n            xi = threshes\n            if (jitter.x) {xi = jitter(xi, amount=jitter.x.amt)}\n            yi = plotList[[i]]\n            if (jitter.y) {yi = jitter(yi, amount=jitter.y.amt)}\n            \n            points(xi, yi, type='b', lwd=1.5,\n                   pch=pchs[i], lty=ltys[i], col=cols[i])\n        }\n    }\n    \n    # add legend\n    if (plotLegend) {\n        # if legendPos specified as xy coordinates\n        if (is.numeric(legendPos) & length(legendPos)==2) {\n            legend(x=legendPos[1], y=legendPos[2], \n                   legend = c(\"Window Size\", names(tuneList)),\n                   horiz = legendHoriz, cex = legendCex,\n                   pch=c(NA, pchs), lty=c(NA, ltys), col=c(NA, cols))\n        } else {\n            # if legendPos specified as \"center\", \"topright\", etc.  \n            legend(legendPos, \n                   legend = c(\"Window Size\", names(tuneList)),\n                   horiz = legendHoriz, cex = legendCex,\n                   pch=c(NA, pchs), lty=c(NA, ltys), col=c(NA, cols))\n        }\n    }\n    \n}\n\n\n#### Expected frequencies calculating functions ####\n\n#' Calculate expected mutation frequencies\n#'\n#' \\code{expectedMutations} calculates the expected mutation frequencies for each \n#' sequence in the input \\code{data.frame}.\n#'\n#' @param    db                  \\code{data.frame} containing sequence data.\n#' @param    sequenceColumn      \\code{character} name of the column containing input \n#'                               sequences.\n#' @param    germlineColumn      \\code{character} name of the column containing \n#'                               the germline or reference sequence.\n#' @param    targetingModel      \\link{TargetingModel} object. Default is \\link{HH_S5F}.\n#' @param    regionDefinition    \\link{RegionDefinition} object defining the regions\n#'                               and boundaries of the Ig sequences.\n#' @param    mutationDefinition  \\link{MutationDefinition} object defining replacement\n#'                               and silent mutation criteria. If \\code{NULL} then \n#'                               replacement and silent are determined by exact \n#'                               amino acid identity.\n#' @param    nproc               \\code{numeric} number of cores to distribute the operation\n#'                               over. If the cluster has already been set the call function with \n#'                               \\code{nproc} = 0 to not reset or reinitialize. Default is \n#'                               \\code{nproc} = 1.\n#' \n#' @return   A modified \\code{db} \\code{data.frame} with expected mutation frequencies \n#'           for each region defined in \\code{regionDefinition}.\n#'          \n#'           The columns names are dynamically created based on the regions in  \n#'           \\code{regionDefinition}. For example, when using the \\link{IMGT_V}\n#'           definition, which defines positions for CDR and FWR, the following columns are\n#'           added:  \n#'           \\itemize{\n#'             \\item  \\code{MU_EXPECTED_CDR_R}:  number of replacement mutations in CDR1 and \n#'                                            CDR2 of the V-segment.\n#'             \\item  \\code{MU_EXPECTED_CDR_S}:  number of silent mutations in CDR1 and CDR2 \n#'                                            of the V-segment.\n#'             \\item  \\code{MU_EXPECTED_FWR_R}:  number of replacement mutations in FWR1, \n#'                                            FWR2 and FWR3 of the V-segment.\n#'             \\item  \\code{MU_EXPECTED_FWR_S}:  number of silent mutations in FWR1, FWR2 and\n#'                                            FWR3 of the V-segment.\n#'           }\n#'           \n#' @details\n#' Only the part of the sequences defined in \\code{regionDefinition} are analyzed. \n#' For example, when using the \\link{IMGT_V} definition, mutations in\n#' positions beyond 312 will be ignored.\n#' \n#' @seealso  \n#' \\link{calcExpectedMutations} is called by this function to calculate the expected \n#' mutation frequencies. See \\link{observedMutations} for getting observed \n#' mutation counts. See \\link{IMGT_SCHEMES} for a set of predefined \n#' \\link{RegionDefinition} objects.\n#' \n#' @examples\n#' # Subset example data\n#' data(ExampleDb, package=\"alakazam\")\n#' db <- subset(ExampleDb, ISOTYPE %in% c(\"IgA\", \"IgG\") & SAMPLE == \"+7d\")\n#'\n#' # Calculate expected mutations over V region\n#' db_exp <- expectedMutations(db,\n#'                             sequenceColumn=\"SEQUENCE_IMGT\",\n#'                             germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n#'                             regionDefinition=IMGT_V,\n#'                             nproc=1)\n#' \n#' # Calculate hydropathy expected mutations over V region\n#' db_exp <- expectedMutations(db,\n#'                            sequenceColumn=\"SEQUENCE_IMGT\",\n#'                            germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n#'                            regionDefinition=IMGT_V,\n#'                            mutationDefinition=HYDROPATHY_MUTATIONS,\n#'                            nproc=1)\n#'\n#' @export\nexpectedMutations <- function(db, \n                              sequenceColumn=\"SEQUENCE_IMGT\",\n                              germlineColumn=\"GERMLINE_IMGT_D_MASK\",\n                              targetingModel=HH_S5F,\n                              regionDefinition=NULL,\n                              mutationDefinition=NULL,\n                              nproc=1) {\n    # Hack for visibility of foreach index variable\n    idx <- NULL\n    \n    # Check for valid columns\n    check <- checkColumns(db, c(sequenceColumn, germlineColumn))\n    if (check != TRUE) { stop(check) }\n    \n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Check mutation definition\n    if (!is.null(mutationDefinition) & !is(mutationDefinition, \"MutationDefinition\")) {\n        stop(deparse(substitute(mutationDefinition)), \" is not a valid MutationDefinition object\")\n    }\n    \n    # Check if mutation count/freq columns already exist\n    # and throw overwritting warning\n    if (!is.null(regionDefinition)) {\n        labels <- regionDefinition@labels\n    } else {\n        labels <- makeNullRegionDefinition()@labels\n    }\n    \n    labels <- paste(\"MU_EXPECTED_\", labels, sep=\"\")\n    \n    label_exists <- labels[labels %in% colnames(db)]\n    if (length(label_exists)>0) {\n        warning(paste0(\"Columns \", \n                       paste(label_exists, collapse=\", \"),\n                       \" exist and will be overwritten\")\n        )\n        db[label_exists] <- NULL\n    }    \n    \n    # Check targeting model\n    if (!is(targetingModel, \"TargetingModel\")) {\n        stop(deparse(substitute(targetingModel)), \" is not a valid TargetingModel object\")\n    }\n    \n    # Convert sequence columns to uppercase\n    db <- toupperColumns(db, c(sequenceColumn, germlineColumn))\n    \n    # If the user has previously set the cluster and does not wish to reset it\n    if(!is.numeric(nproc)){ \n        cluster = nproc \n        nproc = 0\n    }\n    \n    # Ensure that the nproc does not exceed the number of cores/CPUs available\n    nproc <- min(nproc, getnproc(), na.rm=T)\n    \n    # If user wants to paralellize this function and specifies nproc > 1, then\n    # initialize and register slave R processes/clusters & \n    # export all nesseary environment variables, functions and packages.  \n    if (nproc > 1) {        \n        cluster <- parallel::makeCluster(nproc, type = \"PSOCK\")\n        parallel::clusterExport(cluster, list('db', 'sequenceColumn', 'germlineColumn', \n                                              'regionDefinition','targetingModel',\n                                              'calcExpectedMutations','calculateTargeting',\n                                              's2c','c2s','NUCLEOTIDES','HH_S5F',\n                                              'calculateMutationalPaths','CODON_TABLE'),\n                                envir=environment() )\n        registerDoParallel(cluster)\n    } else if (nproc == 1) {\n        # If needed to run on a single core/cpu then, regsiter DoSEQ \n        # (needed for 'foreach' in non-parallel mode)\n        registerDoSEQ()\n    }\n    \n    \n    # Printing status to console\n    cat(\"Calculating the expected frequencies of mutations...\\n\")\n    \n    # Calculate targeting for each sequence (based on the germline)\n    # Should be a 5 x N matrix where N in the number of nucleotides defined by\n    # the regionDefinition\n    numbOfSeqs <- nrow(db)\n    \n    targeting_list <-\n        foreach (idx=iterators::icount(numbOfSeqs)) %dopar% {\n            calcExpectedMutations(germlineSeq=db[[germlineColumn]][idx],\n                                  inputSeq=db[[sequenceColumn]][idx],\n                                  targetingModel=targetingModel,\n                                  regionDefinition=regionDefinition,\n                                  mutationDefinition=mutationDefinition)\n        }\n    \n    # Convert list of expected mutation freq to data.frame\n    if (is.null(regionDefinition)) {\n        labels_length <- length(makeNullRegionDefinition()@labels)\n    } else {\n        labels_length <- length(regionDefinition@labels)\n    }\n    expectedMutationFrequencies <- do.call(rbind, lapply(targeting_list, function(x) { \n        length(x) <- labels_length \n        return(x) })) \n    \n    expectedMutationFrequencies[is.na(expectedMutationFrequencies)] <- 0\n    colnames(expectedMutationFrequencies) <- paste0(\"MU_EXPECTED_\", colnames(expectedMutationFrequencies))\n    \n    # Properly shutting down the cluster\n    if(nproc>1){ parallel::stopCluster(cluster) }\n    \n    # Bind the observed mutations to db\n    db_new <- cbind(db, expectedMutationFrequencies)\n    return(db_new)    \n    \n}\n\n\n#' Calculate expected mutation frequencies of a sequence\n#'\n#' \\code{calcExpectedMutations} calculates the expected mutation\n#' frequencies of a given sequence. This is primarily a helper function for\n#' \\link{expectedMutations}. \n#'\n#' @param    germlineSeq         germline (reference) sequence.\n#' @param    inputSeq            input (observed) sequence. If this is not \\code{NULL}, \n#'                               then \\code{germlineSeq} will be processed to be the same\n#'                               same length as \\code{inputSeq} and positions in \n#'                               \\code{germlineSeq} corresponding to positions with Ns in \n#'                               \\code{inputSeq} will also be assigned an N. \n#' @param    targetingModel      \\link{TargetingModel} object. Default is \\link{HH_S5F}.\n#' @param    regionDefinition    \\link{RegionDefinition} object defining the regions\n#'                               and boundaries of the Ig sequences.\n#' @param    mutationDefinition  \\link{MutationDefinition} object defining replacement\n#'                               and silent mutation criteria. If \\code{NULL} then \n#'                               replacement and silent are determined by exact \n#'                               amino acid identity.\n#'                               \n#' @return   A \\code{numeric} vector of the expected frequencies of mutations in the \n#'           regions in the \\code{regionDefinition}. For example, when using the default \n#'           \\link{IMGT_V} definition, which defines positions for CDR and \n#'           FWR, the following columns are calculated:\n#'           \\itemize{\n#'              \\item  \\code{MU_EXPECTED_CDR_R}:  number of replacement mutations in CDR1 and \n#'                                             CDR2 of the V-segment.\n#'              \\item  \\code{MU_EXPECTED_CDR_S}:  number of silent mutations in CDR1 and CDR2 \n#'                                             of the V-segment.\n#'              \\item  \\code{MU_EXPECTED_FWR_R}:  number of replacement mutations in FWR1, \n#'                                             FWR2 and FWR3 of the V-segment.\n#'              \\item  \\code{MU_EXPECTED_FWR_S}:  number of silent mutations in FWR1, FWR2 and\n#'                                             FWR3 of the V-segment.\n#'            }\n#'           \n#' @details\n#' \\code{calcExpectedMutations} calculates the expected mutation frequencies of a \n#' given sequence and its germline. \n#' \n#' Note, only the part of the sequences defined in \\code{regionDefinition} are analyzed. \n#' For example, when using the default \\link{IMGT_V} definition, mutations in\n#' positions beyond 312 will be ignored.\n#' \n#' @seealso  \\link{expectedMutations} calls this function.\n#' To create a custom \\code{targetingModel} see \\link{createTargetingModel}.\n#' See \\link{calcObservedMutations} for getting observed mutation counts.\n#' \n#' @examples\n#' # Load example data\n#' data(ExampleDb, package=\"alakazam\")\n#' \n#' # Use first entry in the exampled data for input and germline sequence\n#' in_seq <- ExampleDb[[\"SEQUENCE_IMGT\"]][1]\n#' germ_seq <-  ExampleDb[[\"GERMLINE_IMGT_D_MASK\"]][1]\n#' \n#' # Identify all mutations in the sequence\n#' calcExpectedMutations(in_seq, germ_seq)\n#' \n#' # Identify only mutations the V segment minus CDR3\n#' calcExpectedMutations(in_seq, germ_seq, regionDefinition=IMGT_V)\n#' \n#' # Define mutations based on hydropathy\n#' calcExpectedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,\n#'                       mutationDefinition=HYDROPATHY_MUTATIONS)\n#' \n#' @export\ncalcExpectedMutations <- function(germlineSeq,\n                                  inputSeq=NULL,\n                                  targetingModel=HH_S5F,\n                                  regionDefinition=NULL,\n                                  mutationDefinition=NULL) {\n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Check mutation definition\n    if (!is.null(mutationDefinition) & !is(mutationDefinition, \"MutationDefinition\")) {\n        stop(deparse(substitute(mutationDefinition)), \" is not a valid MutationDefinition object\")\n    }\n    \n    # Check targeting model\n    if (!is(targetingModel, \"TargetingModel\")) {\n        stop(deparse(substitute(targetingModel)), \" is not a valid TargetingModel object\")\n    }\n    \n    # Assign codon table\n    codonTable <- if (is.null(mutationDefinition)) { CODON_TABLE } else { mutationDefinition@codonTable }\n    \n    # Get targeting\n    targeting <- calculateTargeting(germlineSeq=germlineSeq, \n                                    inputSeq=inputSeq,\n                                    targetingModel=targetingModel,\n                                    regionDefinition=regionDefinition)\n    \n    # Determine the mutations paths (i.e. determine R and S mutation frequencies)\n    mutationalPaths <- calculateMutationalPaths(germlineSeq=c2s(colnames(targeting)), \n                                                regionDefinition=regionDefinition,\n                                                codonTable=codonTable)\n    \n    typesOfMutations <- c(\"R\", \"S\")\n    mutationalPaths[!(mutationalPaths %in% typesOfMutations)] <- NA\n    \n    if (is.null(regionDefinition)) {\n        rdLength <- max(nchar(inputSeq), nchar(germlineSeq), na.rm=TRUE)\n        regionDefinition <- makeNullRegionDefinition(rdLength)\n    }\n    listExpectedMutationFrequencies <- list()\n    for(region in regionDefinition@regions){\n        for(typeOfMutation in typesOfMutations){\n            region_mutation <- paste(region, typeOfMutation, sep=\"_\")    \n            \n            targeting_region <- targeting[1:4, regionDefinition@boundaries %in% region]\n            mutationalPaths_region <- mutationalPaths[, regionDefinition@boundaries[1:ncol(mutationalPaths)] %in% region]\n            targeting_typeOfMutation_region <- sum(targeting_region[mutationalPaths_region == typeOfMutation], \n                                                   na.rm=TRUE)\n            \n            listExpectedMutationFrequencies[[region_mutation]] <- targeting_typeOfMutation_region\n            \n        }\n    }\n    expectedMutationFrequencies <- unlist(listExpectedMutationFrequencies)\n    expectedMutationFrequencies[!is.finite(expectedMutationFrequencies)] <- NA\n    expectedMutationFrequencies <- expectedMutationFrequencies/sum(expectedMutationFrequencies, na.rm=TRUE)\n    return(expectedMutationFrequencies)    \n}\n\n\ncalculateTargeting <- function(germlineSeq,\n                               inputSeq=NULL,\n                               targetingModel=HH_S5F,\n                               regionDefinition=NULL) {\n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Check targeting model\n    if (!is(targetingModel, \"TargetingModel\")) {\n        stop(deparse(substitute(targetingModel)), \" is not a valid TargetingModel object\")\n    }\n    \n    # If an inputSequence is passed then process the germlineSequence\n    # to be the same legth, mask germlineSequence with Ns where inputSequence is also N\n    # If not needed then  you may skip this step by passing in inputSequence=NULL \n    # (which is default). \n    if(!is.null(inputSeq)){    \n        # Trim the input and germline sequence to the shortest\n        len_inputSeq <- nchar(inputSeq)\n        len_germlineSeq <- nchar(germlineSeq)\n        # If a regionDefinition is passed,\n        # then only analyze till the end of the defined length\n        if(!is.null(regionDefinition)){\n            length_regionDefinition  <- regionDefinition@seqLength\n        } else{\n            length_regionDefinition <- max(len_inputSeq, len_germlineSeq, na.rm=TRUE)\n        }\n        len_shortest <- min( c(len_inputSeq,len_germlineSeq,length_regionDefinition),  na.rm=TRUE)\n        \n        c_inputSeq <- s2c(inputSeq)[1:len_shortest]\n        c_germlineSeq <- s2c(germlineSeq)[1:len_shortest]\n        \n        # If the sequence and germline (which now should be the same length) is shorter\n        # than the length_regionDefinition, pad it with Ns\n        if(len_shortest<length_regionDefinition){\n            fillWithNs <- array(\"N\",length_regionDefinition-len_shortest)\n            c_inputSeq <- c( c_inputSeq, fillWithNs)\n            c_germlineSeq <- c( c_germlineSeq, fillWithNs)\n        }\n        \n        # Mask germline with Ns where input sequence has Ns\n        c_germlineSeq[ c_inputSeq==\"N\" |  !c_inputSeq%in%c(NUCLEOTIDES[1:5],\".\") ] = \"N\"    \n        s_germlineSeq <- c2s(c_germlineSeq)\n    }else{\n        s_germlineSeq <- germlineSeq\n        c_germlineSeq <- s2c(s_germlineSeq)\n    }\n    \n    # Removing IMGT gaps (they should come in threes)\n    # After converting ... to XXX any other . is not an IMGT gap & will be treated like N\n    gaplessSeq <- gsub(\"\\\\.\\\\.\\\\.\", \"XXX\", s_germlineSeq)\n    #If there is a single gap left convert it to an N\n    gaplessSeq <- gsub(\"\\\\.\", \"N\", gaplessSeq)\n    \n    # Re-assigning s_germlineSeq (now has all \".\" that are not IMGT gaps converted to Ns)\n    s_germlineSeq <- gsub(\"XXX\", \"...\", gaplessSeq)\n    c_germlineSeq <- s2c(s_germlineSeq)\n    # Matrix to hold targeting values for each position in c_germlineSeq\n    germlineSeqTargeting <- matrix(NA, \n                                   ncol=nchar(s_germlineSeq), \n                                   nrow=length(NUCLEOTIDES[1:5]),\n                                   dimnames=list(NUCLEOTIDES[1:5], c_germlineSeq))\n    \n    # Now remove the IMGT gaps so that the correct 5mers can be made to calculate\n    # targeting. e.g.\n    # GAGAAA......TAG yields: \"GAGAA\" \"AGAAA\" \"GAAAT\" \"AAATA\" \"AATAG\"\n    # (because the IMGT gaps are NOT real gaps in sequence!!!)\n    gaplessSeq <- gsub(\"\\\\.\\\\.\\\\.\", \"\", s_germlineSeq)\n    gaplessSeqLen <- nchar(gaplessSeq)\n    \n    #Slide through 5-mers and look up targeting\n    gaplessSeq <- paste(\"NN\", gaplessSeq, \"NN\", sep=\"\")\n    gaplessSeqLen <- nchar(gaplessSeq)\n    pos<- 3:(gaplessSeqLen - 2)\n    subSeq =  substr(rep(gaplessSeq, gaplessSeqLen - 4), (pos - 2), (pos + 2))\n    germlineSeqTargeting_gapless <- targetingModel@targeting[,subSeq]\n    #     germlineSeqTargeting_gapless <- sapply(subSeq, function(x) { \n    #         targetingModel@targeting[, x] })\n    \n    germlineSeqTargeting[, c_germlineSeq != \".\"] <- germlineSeqTargeting_gapless  \n    \n    # Set self-mutating targeting values to be NA\n    mutatingToSelf <- colnames(germlineSeqTargeting)\n    mutatingToSelf[!(mutatingToSelf %in% NUCLEOTIDES[1:5])] <- \"N\"\n    #     # TODO: What's with this <<- business?\n    #     # TODO: I think this is assigning NA to all self-mutations, which are already NA\n    #     sapply(1:ncol(germlineSeqTargeting), function(pos) { germlineSeqTargeting[mutatingToSelf[pos], pos] <<- NA })\n    \n    germlineSeqTargeting[!is.finite(germlineSeqTargeting)] <- NA\n    return(germlineSeqTargeting)\n}\n\ncalculateMutationalPaths <- function(germlineSeq,\n                                     inputSeq=NULL,\n                                     regionDefinition=NULL,\n                                     codonTable=NULL) {    \n    # Check region definition\n    if (!is.null(regionDefinition) & !is(regionDefinition, \"RegionDefinition\")) {\n        stop(deparse(substitute(regionDefinition)), \" is not a valid RegionDefinition object\")\n    }\n    \n    # Set codon table if required\n    if (is.null(codonTable)) { codonTable <- CODON_TABLE }\n    \n    # If an inputSequence is passed then process the germlineSequence\n    # to be the same length, mask germlineSequence with Ns where inputSequence is also N\n    # If this function is being called after running calculateTargeting you may skip\n    # this step by passing in inputSequence=NULL (which is default). This way you save\n    # some processing time.\n    if(!is.null(inputSeq)){    \n        # Trim the input and germline sequence to the shortest\n        len_inputSeq <- nchar(inputSeq)\n        len_germlineSeq <- nchar(germlineSeq)\n        # If a regionDefinition is passed,\n        # then only analyze till the end of the defined length\n        if(!is.null(regionDefinition)){\n            length_regionDefinition  <- regionDefinition@seqLength\n        } else{\n            length_regionDefinition <- max(len_inputSeq, len_germlineSeq, na.rm=TRUE)\n        }\n        len_shortest <- min( c(len_inputSeq,len_germlineSeq,length_regionDefinition),  na.rm=TRUE)\n        \n        c_inputSeq <- s2c(inputSeq)[1:len_shortest]\n        c_germlineSeq <- s2c(germlineSeq)[1:len_shortest]\n        \n        # If the sequence and germline (which now should be the same length) is shorter\n        # than the length_regionDefinition, pad it with Ns\n        if(len_shortest<length_regionDefinition){\n            fillWithNs <- array(\"N\",length_regionDefinition-len_shortest)\n            c_inputSeq <- c( c_inputSeq, fillWithNs)\n            c_germlineSeq <- c( c_germlineSeq, fillWithNs)\n        }\n        \n        # Mask germline with Ns where input sequence has Ns\n        c_germlineSeq[c_inputSeq==\"N\" |  !c_inputSeq %in% c(NUCLEOTIDES[1:5], \".\") ] = \"N\"    \n        s_germlineSeq <- c2s(c_germlineSeq)\n    } else {\n        s_germlineSeq <- germlineSeq\n        c_germlineSeq <- s2c(s_germlineSeq)\n    }\n    \n    \n    s_germlineSeq_len <- nchar(s_germlineSeq)    \n    vecCodons <- sapply({1:(s_germlineSeq_len/3)}*3 - 2, function(x) { substr(s_germlineSeq, x, x + 2) })\n    vecCodons[!vecCodons %in% colnames(codonTable)] <- \"NNN\"\n    matMutationTypes = matrix(codonTable[, vecCodons], nrow=4, byrow=F,\n                              dimnames=list(NUCLEOTIDES[1:4], c_germlineSeq[ 1:(3 * length(vecCodons))]))\n    \n    return(matMutationTypes)\n}\n\n#### Additional helper functions ####\n\n# Convert one or more nucleotide characters to IUPAC code \n# for incomplete nucleic acid specification\n# \n# @param   nucs     a character vector of nucleotides. One or more of \n#                   \\code{c(\"A\", \"C\", \"G\", \"T\")}.\n# \n# @return  a single character from the IUPAC ambiguous code.\n#\n# tests\n# nucs2IUPAC(c(\"A\", \"T\")) == \"W\"\n# nucs2IUPAC(c(\"A\", \"T\", \"G\", \"C\")) == \"N\"\n# nucs2IUPAC(c(\"C\", \"T\", \"G\")) == \"B\"\n# nucs2IUPAC(c(\"C\", \"T\", \"G\", \"G\")) == \"B\"\n#\nnucs2IUPAC = function(nucs) {\n    # input nucleotides must be one of the characters allowed\n    legal = c(\"A\", \"C\", \"G\", \"T\")\n    if (sum(! nucs %in% legal)>0) {\n        stop(\"Input nucleotides must be one of A, C, G, or T.\")\n    }\n    \n    # sort by alphabetical order (important)\n    nucs = sort(unique(nucs))\n    # concatenate\n    nucs = c2s(nucs)\n    \n    # convert\n    return(IUPAC_DNA_2[nucs])\n}\n\n# Convert one or more characters including dash and dots to ambiguous characters\n# \n# @param   chars     a character vector of nucleotides. One or more of \n#                    \\code{c(\"A\", \"C\", \"G\", \"T\", \"N\", \"-\", \".\")}.\n# \n# @return  a single IUPAC character or \"-\" or \".\"\n#\n# tests\n# chars2Ambiguous(c(\"A\", \"T\")) ==\"W\"\n# chars2Ambiguous(c(\"A\", \"T\", \"N\")) ==\"W\"\n# chars2Ambiguous(c(\"A\", \"T\", \"G\", \"C\")) ==\"N\"\n# chars2Ambiguous(c(\"A\", \"T\", \"G\", \"C\", \"N\")) ==\"N\"\n# chars2Ambiguous(c(\"A\", \"T\", \"G\", \"C\", \"-\")) ==\"N\"\n# chars2Ambiguous(c(\".\", \"-\")) ==\"-\"\n# chars2Ambiguous(c(\".\", \"N\")) ==\"N\"\n# chars2Ambiguous(c(\".\", \"A\", \"T\")) ==\"W\"\n#\nchars2Ambiguous = function(chars) {\n    # chars must all be unique\n    stopifnot( length(unique(chars)) == length(chars) )\n    \n    # input characters must be one of the characters allowed\n    legal = c(\"A\", \"C\", \"G\", \"T\", \"N\", \"-\", \".\")\n    if (sum(! chars %in% legal)>0) {\n        stop(\"Input characters must be one of A, C, G, T, N, - (dash), or . (dot)\")\n    }\n    \n    # if any of A, T, G, C, N appears\n    if (any(chars %in% c(\"A\",\"C\",\"G\",\"T\",\"N\"))) {\n        \n        # ignore - and .\n        idx.dash.dot = which(chars==\"-\" | chars==\".\")\n        if (length(idx.dash.dot)>0) {\n            chars = chars[-idx.dash.dot]\n        }\n        \n        # if only N appears\n        if (sum(chars==\"N\")==length(chars)) {\n            return(\"N\")\n        } else {\n            # otherwise, if there are any of A, T, G, C\n            # remove N\n            # e.g. AGN would be treated as AG (R)\n            # e.g. ATGN would be treated as AGT (D)\n            # e.g. ATGCN would be treated as ACGT (N)\n            idx.N = which(chars==\"N\")\n            if (length(idx.N)>0) {\n                chars = chars[-idx.N]\n            } \n            return(nucs2IUPAC(chars))\n        }\n        \n    } else {\n        # otherwise, if only one or both of - and . appear(s)    \n        # if both - and . appear, return -\n        if (sum(chars %in% c(\"-\", \".\"))==2) {\n            return(\"-\")\n        } else {\n            # if only - or . appears, return that\n            return(chars)\n        }\n    }\n    \n}\n\n# Convert IUPAC incomplete nucleic acid to one or more characters\n#\n# @param   code       a single IUPAC character.\n# @param   excludeN   if \\code{TRUE}, do not translate when \\code{code} \n#                     is \\code{N}. Default is \\code{TRUE}.\n# @return  a character vector of nucleotides. One or more of \n#          \\code{c(\"A\", \"C\", \"G\", \"T\")}.\n# tests\n# IUPAC2nucs(code=\"N\", excludeN=T)==\"N\"\n# IUPAC2nucs(code=\"N\", excludeN=F)==c(\"A\", \"C\", \"G\", \"T\")\n# IUPAC2nucs(code=\"S\", excludeN=T)==c(\"C\", \"G\")\n# IUPAC2nucs(code=\"S\", excludeN=F)==c(\"C\", \"G\")\n#\nIUPAC2nucs = function(code, excludeN=TRUE) {\n    # input character must be one of IUPAC codes\n    if (! code %in% names(IUPAC_DNA) ) {\n        stop(\"Input character must be one of IUPAC DNA codes.\")\n    }\n    \n    # convert\n    if (code==\"N\" & excludeN) {\n        return(code)\n    } else {\n        return(IUPAC_DNA[[code]])\n    }\n}\n\n# Given a nuclotide position, returns the codon number\n# e.g. nuc 86  = codon 29\ngetCodonNumb <- function(nucPos){\n    return( ceiling(nucPos/3) )\n}\n\n# Given a codon, returns all the nuc positions that make the codon\ngetCodonNucs <- function(codonNumb){\n    getCodonPos(codonNumb*3)\n}\n\n# Given a nucleotide postions return the position in the codon\ngetContextInCodon <- function(nucPos){\n    return( {nucPos-1}%%3+1 )\n}\n\n# Given a nuclotide position, returns the pos of the 3 nucs that made the codon\n# e.g. nuc 86 is part of nucs 85,86,87\ngetCodonPos <- function(nucPos) {\n    codonNum =  (ceiling(nucPos / 3)) * 3\n    return ((codonNum - 2):codonNum)\n}\n\n# Translate codon to amino acid\ntranslateCodonToAminoAcid <- function(Codon) {\n    return (AMINO_ACIDS[Codon])\n}\n\n# Given two codons, tells you if the mutation is R or S (based on your definition)\n#\n# @param   codonFrom         starting codon. IUPAC ambiguous characters are allowed.\n# @param   codonTo           ending codon.  IUPAC ambiguous characters are allowed.\n# @param   aminoAcidClasses  vector of amino acid trait classes\n#                            if NULL then R or S is determined by amino acid identity\n# @return  A vector with entries named by mutation type, including \"R\" (replacement), \n#          \"S\" (silent), \"Stop\" (stop) or \"na\" (input codons are identical or include NA).\n#          Each entry indicates the count of its corresponding type of mutation.\n#\n# @examples\n# # Without classes\n# mutationType(\"TTT\", \"TTC\")\n# mutationType(\"TTT\", \"TTA\")\n# mutationType(\"TTT\", \"TGA\")\n# mutationType(\"TGG\", \"TWG\")\n#\n# # With classes\n# classes <- HYDROPATHY_MUTATIONS@classes\n# mutationType(\"TTT\", \"TTC\", aminoAcidClasses=classes)\n# mutationType(\"TTT\", \"TTA\", aminoAcidClasses=classes)\n# mutationType(\"TTT\", \"TCT\", aminoAcidClasses=classes)\n# mutationType(\"TTT\", \"TGA\", aminoAcidClasses=classes)\n# \n# testing\n# TGG (Trp) -> TGG (Trp); expect na 1\n# mutationType(\"TGG\", \"TGG\") \n# TGG (Trp) -> TAG (Stop); expect Stop 1\n# mutationType(\"TGG\", \"TAG\") \n# TGG (Trp) -> TCG (Ser); expect R 1\n# mutationType(\"TGG\", \"TCG\") \n# TGG (Trp) -> TAG (Stop), TGG (Trp) -> TTG (Leu); expect R 1 + \n# mutationType(\"TGG\", \"TWG\") \n# TGG (Trp) -> TCG (Ser), TGG (Trp) -> TGG (Trp); expect R 1 + na 1\n# mutationType(\"TGG\", \"TSG\") \n# TGG (Trp) -> TCA (Ser)\n# TGG (Trp) -> TCC (SER)\n# TGG (Trp) -> TGA (Stop)\n# TGG (Trp) -> TGC (Cys)\n# expect R 3 + stop 1\n# mutationType(\"TGG\", \"TSM\") \nmutationType <- function(codonFrom, codonTo, aminoAcidClasses=NULL) {\n    # codonFrom=\"TTT\"; codonTo=\"TTA\"\n    # codonFrom=\"TTT\"; codonTo=\"TGA\"\n    \n    # placeholder for tabulation\n    tab = setNames(object=rep(0, 4), nm=c(\"R\", \"S\", \"Stop\", \"na\"))\n    \n    if ( grepl(pattern=\"[-.]\", x=codonFrom) | grepl(pattern=\"[-.]\", x=codonTo) ) {\n        tab[\"na\"] = 1\n    } else {\n        # get all combinations of codons made up of unambiguous characters in data.frame\n        # simplify=FALSE is essential for working with codons containing no ambiguous char\n        # expand.grid works with codons containing no ambiguous char without problem\n        # crucial to have excludeN=TRUE for IUPAC2nucs (so that codons like NNN lead to NA)\n        codonFrom.all = expand.grid(sapply(s2c(codonFrom), IUPAC2nucs, excludeN=TRUE, simplify=FALSE))\n        codonTo.all = expand.grid(sapply(s2c(codonTo), IUPAC2nucs, excludeN=TRUE, simplify=FALSE))\n        \n        for (i in 1:nrow(codonFrom.all)) {\n            for (j in 1:nrow(codonTo.all)) {\n                # can't just as.character(codonFrom.all[i, ]); will get numbers like \"111\"\n                cur.codonFrom = c2s(as.character(unlist(codonFrom.all[i, ], use.names=F)))\n                cur.codonTo = c2s(as.character(unlist(codonTo.all[j, ], use.names=F)))\n                \n                # if codons are the same, there is no mutation; count as NA\n                if (cur.codonFrom == cur.codonTo) {\n                    tab[\"na\"] = tab[\"na\"] + 1\n                } else {\n                    # Translate codons\n                    aaFrom <- translateCodonToAminoAcid(cur.codonFrom)\n                    aaTo <- translateCodonToAminoAcid(cur.codonTo)\n                    \n                    # If any codon is NA then return NA\n                    if (any(is.na(c(codonFrom, codonTo, aaFrom, aaTo)))) { \n                        tab[\"na\"] = tab[\"na\"] + 1\n                    } else if (any(c(aaFrom, aaTo) == \"*\")) {\n                        # If any amino acid is Stop then return \"Stop\"\n                        tab[\"Stop\"] = tab[\"Stop\"] + 1\n                    } else if (is.null(aminoAcidClasses)) {\n                        # Check for exact identity if no amino acid classes are specified\n                        mutation <- if (aaFrom == aaTo) { \"S\" } else { \"R\" }\n                        tab[mutation] = tab[mutation]+1\n                    } else {\n                        # Check for amino acid class identity if classes are specified\n                        mutation <- if (aminoAcidClasses[aaFrom] == aminoAcidClasses[aaTo]) { \"S\" } else { \"R\" }\n                        tab[mutation] = tab[mutation]+1\n                    }\n                }\n            }\n        }\n    }\n    \n    stopifnot(sum(tab)>0)\n    return(tab)\n}\n\n",
    "created" : 1497298308719.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3009404878",
    "id" : "C20B3987",
    "lastKnownWriteTime" : 1497245991,
    "last_content_update" : 1497245991,
    "path" : "~/sync_smartgit/shazam/R/MutationProfiling.R",
    "project_path" : "R/MutationProfiling.R",
    "properties" : {
        "docOutlineSize" : "233",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}