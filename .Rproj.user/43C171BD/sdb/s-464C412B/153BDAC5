{
    "collab_server" : "",
    "contents" : "# SHMulate\n\n#' @include MutationProfiling.R\n#' @include Shazam.R\nNULL\n\n\n#### SHMulation ####\n\n#' Simulate mutations in a single sequence\n#'\n#' Generates random mutations in a sequence iteratively using a targeting model.\n#' Targeting probabilities at each position are updated after each iteration.\n#' \n#' @param    sequence        sequence string in which mutations are to be introduced.\n#' @param    mutations       number of mutations to be introduced into \\code{sequence}.\n#' @param    targetingModel  5-mer \\link{TargetingModel} object to be used for computing \n#'                           probabilities of mutations at each position. Defaults to\n#'                           \\link{HH_S5F}.\n#'                           \n#' @return   A string defining the mutated sequence.\n#' \n#' @seealso  See \\link{shmulateTree} for imposing mutations on a lineage tree. \n#'           See \\link{HH_S5F} and \\link{MK_RS5NF} for predefined \n#'           \\link{TargetingModel} objects.\n#' \n#' @examples\n#' # Define example input sequence\n#' sequence <- \"NGATCTGACGACACGGCCGTGTATTACTGTGCGAGAGATAGTTTA\"\n#' \n#' # Simulate using the default human 5-mer targeting model\n#' shmulateSeq(sequence, mutations=6)\n#' \n#' @export\nshmulateSeq <- function(sequence, mutations, targetingModel=HH_S5F) {\n    #* counts on constant variables CODON_TABLE, NUCLEOTIDES (ACTGN-.)\n    \n    # Check targeting model\n    if (!is(targetingModel, \"TargetingModel\")) {\n        stop(deparse(substitute(targetingModel)), \" is not a valid TargetingModel object\")\n    }\n\n    # Trim sequence to last codon (getCodonPos from MutationProfiling.R)\n    if(getCodonPos(stri_length(sequence))[3] > stri_length(sequence)) {\n        sim_seq <- substr(sequence, 1, getCodonPos(stri_length(sequence))[1]-1)\n    } else {\n        sim_seq <- sequence\n    }\n    sim_seq <- gsub(\"\\\\.\", \"-\", sim_seq)\n    sim_leng <- stri_length(sim_seq)\n    stopifnot((sim_leng %% 3)==0)\n    \n    # Calculate possible mutations (given codon table)\n    mutation_types <- computeMutationTypes(sim_seq)\n    \n    # Calculate probabilities of mutations at each position given targeting\n    # from MutationProfiling.R; includes a N row\n    targeting <- calculateTargeting(germlineSeq = sim_seq, targetingModel = targetingModel) \n    # keep only ACGT rows\n    targeting <- targeting[NUCLEOTIDES[1:4], ] \n    # set NA to 0\n    targeting[is.na(targeting)] <- 0 \n    # Make probability of stop codon 0\n    targeting[mutation_types==\"Stop\"] <- 0\n    \n    # Initialize counters\n    total_muts <- 0\n    positions <- numeric(mutations)\n    \n    while(total_muts < mutations) {\n        # Get position to mutate and update counters\n        mutpos <- sampleMut(sim_leng, targeting, positions)\n        total_muts <- total_muts + 1\n        positions[total_muts] <- mutpos$pos\n        \n        # Implement mutation in simulation sequence\n        mut_nuc <- 4 - (4*mutpos$pos - mutpos$mut)\n        sim_char <- s2c(sim_seq)\n        sim_char[mutpos$pos] <- NUCLEOTIDES[mut_nuc]\n        sim_seq <- c2s(sim_char)\n        \n        # Update targeting\n        lower <- max(mutpos$pos-4, 1)\n        upper <- min(mutpos$pos+4, sim_leng)\n        targeting[, lower:upper] <- calculateTargeting(germlineSeq=substr(sim_seq, lower, upper),\n                                                       targetingModel = targetingModel)[NUCLEOTIDES[1:4], ]\n        targeting[is.na(targeting)] <- 0\n        \n        # Update possible mutations\n        lower <- getCodonPos(lower)[1]\n        upper <- getCodonPos(upper)[3]\n        mutation_types[, lower:upper] <- computeMutationTypes(substr(sim_seq, lower, upper))\n        # Make probability of stop codon 0\n        if(any(mutation_types[, lower:upper]==\"Stop\", na.rm=T)) {\n            targeting[, lower:upper][mutation_types[, lower:upper]==\"Stop\"] <- 0\n        }\n    }\n    return(sim_seq)\n}\n\n\n#' Simulate mutations in a lineage tree\n#'\n#' \\code{shmulateTree} returns a set of simulated sequences generated from an input sequence and an\n#' lineage tree. The input sequence is used to replace the MRCA node of the \\code{igraph} object\n#' defining the lineage tree. Sequences are then simulated with mutations corresponding to edge \n#' weights in the tree. Sequences will not be generated for groups of nodes that are specified \n#' to be excluded.\n#'\n#' @param    sequence        string defining the MRCA sequence to seed mutations from.\n#' @param    graph           \\code{igraph} object defining the seed lineage tree, with \n#'                           vertex annotations, whose edges are to be recreated.\n#' @param    targetingModel  5-mer \\link{TargetingModel} object to be used for computing \n#'                           probabilities of mutations at each position. Defaults to\n#'                           \\link{HH_S5F}.\n#' @param   field            annotation to use for both unweighted path length exclusion and\n#'                           consideration as the MRCA node. If \\code{NULL} do not exclude \n#'                           any nodes.\n#' @param   exclude          vector of annotation values in \\code{field} to exclude from potential\n#'                           MRCA set. If \\code{NULL} do not exclude any nodes. \n#'                           Has no effect if \\code{field=NULL}.\n#' @param   junctionWeight   fraction of the nucleotide sequence that is within the junction \n#'                           region. When specified this adds a proportional number of  \n#'                           mutations to the trunk of the tree. Requires a value between \n#'                           0 and 1. If \\code{NULL} then edge weights are unmodified\n#'                           from the input \\code{graph}.\n#'\n#' @return   A \\code{data.frame} of simulated sequences with columns:\n#'           \\itemize{\n#'             \\item \\code{NAME}:      name of the corresponding node in the input \n#'                                     \\code{graph}.  \n#'             \\item \\code{SEQUENCE}:  mutated sequence.\n#'             \\item \\code{DISTANCE}:  Hamming distance of the mutated sequence from \n#'                                     the seed \\code{sequence}.\n#'           }\n#' \n#' @seealso  See \\link{shmulateSeq} for imposing mutations on a single sequence. \n#'           See \\link{HH_S5F} and \\link{MK_RS5NF} for predefined \n#'           \\link{TargetingModel} objects.\n#' \n#' @examples\n#' # Load example lineage and define example MRCA\n#' data(ExampleTrees, package=\"alakazam\")\n#' graph <- ExampleTrees[[17]]\n#' sequence <- \"NGATCTGACGACACGGCCGTGTATTACTGTGCGAGAGATAGTTTA\"\n#' \n#' # Simulate using the default human 5-mer targeting model\n#' shmulateTree(sequence, graph)\n#' \n#' # Simulate using the mouse 5-mer targeting model\n#' # Exclude nodes without a sample identifier\n#' # Add 20% mutation rate to the trunk\n#' shmulateTree(sequence, graph, targetingModel=MK_RS5NF,\n#'              field=\"SAMPLE\", exclude=NA, junctionWeight=0.2)\n#'  \n#' @export\nshmulateTree <- function(sequence, graph, targetingModel=HH_S5F,\n                         field=NULL, exclude=NULL, junctionWeight=NULL) {\n    ## DEBUG\n    # targetingModel=HH_S5F; field=NULL; exclude=NULL; junctionWeight=NULL\n    \n    # Check targeting model\n    if (!is(targetingModel, \"TargetingModel\")) {\n        stop(deparse(substitute(targetingModel)), \" is not a valid TargetingModel object\")\n    }\n    \n    # Determine MRCA of lineage tree\n    mrca_df <- alakazam::getMRCA(graph, path=\"distance\", root=\"Germline\", \n                                 field=field, exclude=exclude)\n    \n    # Get adjacency matrix\n    adj <- as_adjacency_matrix(graph, attr=\"weight\", sparse=FALSE)\n    # Get names of nodes for which sequences are not to be returned\n    skip_names <- c()\n    if (!is.null(field)) {\n        g <- vertex_attr(graph, name=field)\n        g_names <- vertex_attr(graph, name=\"name\")\n        skip_names <- g_names[g %in% exclude]\n    }\n    \n    # Create data.frame to hold simulated sequences\n    sim_tree <- data.frame(\"NAME\"=mrca_df$NAME[1],\n                           \"SEQUENCE\"=sequence, \n                           \"DISTANCE\"=0,\n                           stringsAsFactors=F)\n    parent_nodes <- mrca_df$NAME[1]\n    nchild <- sum(adj[parent_nodes, ] > 0)\n    \n    # Add trunk mutations proportional to fraction of sequence in junction\n    if(!is.null(junctionWeight)) {\n        adj[parent_nodes, ] <- round(adj[parent_nodes, ] * (1 + junctionWeight))\n    }\n    while(nchild > 0) {\n        new_parents <- c()\n        # Loop through parent-children combos\n        for(p in parent_nodes) {\n            children <- colnames(adj)[adj[p, ] > 0]\n            for(ch in children) {\n                # Add child to new parents\n                new_parents <- union(new_parents, ch)\n                # Simulate sequence for that edge\n                seq <- shmulateSeq(sequence=sim_tree$SEQUENCE[sim_tree$NAME == p], \n                                   mutations=adj[p, ch],\n                                   targetingModel=targetingModel)\n                new_node <- data.frame(\"NAME\"=ch, \"SEQUENCE\"=seq, \"DISTANCE\"=adj[p, ch])\n                # Update output data.frame (bind_rows from dplyr)\n                sim_tree <- bind_rows(sim_tree, new_node)\n            }\n        }\n        # Re-calculate number of children\n        parent_nodes <- new_parents\n        nchild <- sum(adj[parent_nodes, ] > 0)\n    }\n    # Remove sequences that are to be excluded\n    sim_tree <- sim_tree[!(sim_tree$NAME %in% skip_names), ]\n    return(sim_tree)\n}\n\n\n#### Helper functions ####\n\n# Compute the mutations types\n#\n# For each position in the input sequence, use \\code{CODON_TABLE} to\n# determine what types of mutations are possible. Returns \\code{matrix}\n# of all possible mutations and corresponding types.\n#\n# @param   seq   sequence for which to compute mutation types\n# @return  A \\code{matrix} of mutation types for each position in the sequence.\ncomputeMutationTypes <- function(seq){\n    #* counts on constant variable CODON_TABLE, NUCLEOTIDES (ACTGN-.)\n    #* caution: this breaks down if length of seq is not a multiple of 3\n    \n    leng_seq <- stri_length(seq)\n    try(if( (leng_seq %%3 !=0) ) stop(\"length of input sequence must be a multiple of 3\"))\n    \n    codons <- sapply(seq(1, leng_seq, by=3), function(x) {substr(seq,x,x+2)})\n    mut_types <- matrix(unlist(CODON_TABLE[, codons]), ncol=leng_seq, nrow=4, byrow=F)\n    dimnames(mut_types) <-  list(NUCLEOTIDES[1:4], 1:leng_seq)\n    return(mut_types)\n}\n\n\n# Pick a position to mutate\n#\n# Sample positions in the sequence to mutate given targeting probability\n# until a new position is selected. This new position is then added to the\n# vector of mutated positions and returned.\n#\n# @param   sim_leng   length of sequence in which mutation is being simulated\n# @param   targeting  probabilities of each position in the sequence being mutated\n# @param   positions  vector of positions which have already been mutated\n#\n# @return   A \\code{list} of position being mutated and updated vector of mutated positions.\nsampleMut <- function(sim_leng, targeting, positions) {\n    pos <- 0\n    # Sample mutations until new position is selected\n    while (pos %in% positions) {\n        # Randomly select a mutation\n        mut <- sample(1:(4*sim_leng), 1, replace=F, prob=as.vector(targeting))\n        pos <- ceiling(mut/4)\n    }\n    return(list(mut=mut, pos=pos))\n}\n",
    "created" : 1497298412798.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "483719924",
    "id" : "153BDAC5",
    "lastKnownWriteTime" : 1497026380,
    "last_content_update" : 1497026380,
    "path" : "~/sync_smartgit/shazam/R/Shmulate.R",
    "project_path" : "R/Shmulate.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}